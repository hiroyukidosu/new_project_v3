// MedicationHomePage// メインホーム画面 - タブバーで各機能にアクセスします// Dart core importsimport 'dart:async';import 'dart:convert';import 'dart:io';import 'dart:ui';// Flutter core importsimport 'package:flutter/material.dart';import 'package:flutter/services.dart';import 'package:flutter/foundation.dart';// Third-party package importsimport 'package:table_calendar/table_calendar.dart';import 'package:path_provider/path_provider.dart';import 'package:intl/intl.dart';import 'package:intl/date_symbol_data_local.dart';import 'package:flutter_local_notifications/flutter_local_notifications.dart';import 'package:firebase_core/firebase_core.dart';import 'package:firebase_crashlytics/firebase_crashlytics.dart';import 'package:timezone/data/latest.dart' as tz;import 'package:timezone/timezone.dart' as tz;import 'package:permission_handler/permission_handler.dart';import 'package:share_plus/share_plus.dart';import 'package:hive_flutter/hive_flutter.dart';import 'package:shared_preferences/shared_preferences.dart';import 'package:fl_chart/fl_chart.dart';import 'package:in_app_purchase/in_app_purchase.dart';// Local importsimport '../models/medication_memo.dart';import '../models/medicine_data.dart';import '../models/medication_info.dart';import '../services/app_preferences.dart';import '../services/medication_service.dart';import '../services/notification_service.dart';import '../services/trial_service.dart';import '../services/in_app_purchase_service.dart';import '../widgets/medication_card.dart';import '../widgets/weekday_selector.dart';import '../widgets/memo_dialog.dart';import '../widgets/trial_limit_dialog.dart';import '../utils/logger.dart';import '../utils/error_handler.dart';import '../utils/constants.dart';import '../core/snapshot_service.dart';import '../utils/locale_helper.dart';

class MedicationHomePage extends StatefulWidget {
  const MedicationHomePage({super.key});
  @override
  State<MedicationHomePage> createState() => _MedicationHomePageState();
}
class _MedicationHomePageState extends State<MedicationHomePage> with TickerProviderStateMixin {
  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  final Set<DateTime> _selectedDates = <DateTime>{};
  // 動的に追加される薬のリスト
  List<Map<String, dynamic>> _addedMedications = [];
  late TabController _tabController;
  bool _notificationError = false;
  bool _isInitialized = false;
  bool _isAlarmPlaying = false;
  bool _isLoading = false; // ✅ 修正：ローディング状態を追加
  Map<String, Map<String, MedicationInfo>> _medicationData = {};
  Map<String, double> _adherenceRates = {};
  List<MedicineData> _medicines = [];
  List<MedicationMemo> _medicationMemos = [];
  Timer? _debounce;
  Timer? _saveDebounceTimer; // ✅ 修正：保存用デバウンスタイマーを追加
  StreamSubscription<List<PurchaseDetails>>? _subscription; // ✅ 修正：StreamSubscriptionを追加
  
  // ✅ 修正：変更フラグ変数を追加
  bool _medicationMemoStatusChanged = false;

  bool _weekdayMedicationStatusChanged = false;
  bool _addedMedicationsChanged = false;
 
  
  // ✅ アラームタブのキー（強制再構築用）
  Key _alarmTabKey = UniqueKey();
  
  // ✅ 統計タブ用のScrollController
  final ScrollController _statsScrollController = ScrollController();
  
  // ✅ 任意の日数の遵守率機能用の変数
  double? _customAdherenceResult;
  int? _customDaysResult;
  final TextEditingController _customDaysController = TextEditingController();
  final FocusNode _customDaysFocusNode = FocusNode();
  
  
  // ✅ 手動復元機能のための変数
  DateTime? _lastOperationTime;
  
  // ✅ 自動バックアップ機能のための変数
  Timer? _autoBackupTimer;
  bool _autoBackupEnabled = true;
 
  // ✅ 修正：データキーの統一とバージョン管理
  static const String _medicationMemosKey = 'medication_memos_v2';
  static const String _medicationMemoStatusKey = 'medication_memo_status_v2';
  static const String _weekdayMedicationStatusKey = 'weekday_medication_status_v2';
  static const String _addedMedicationsKey = 'added_medications_v2';
  
  // バックアップキー
  static const String _backupSuffix = '_backup';

  
  // メモ用の状態変数
  final TextEditingController _memoController = TextEditingController();
  final FocusNode _memoFocusNode = FocusNode();
  bool _isMemoFocused = false;
  bool _memoSnapshotSaved = false; // メモ変更時のスナップショット保存フラグ
  // ✅ 部分更新用のValueNotifier
  final ValueNotifier<String> _memoTextNotifier = ValueNotifier<String>('');
  final ValueNotifier<Map<String, Color>> _dayColorsNotifier = ValueNotifier<Map<String, Color>>({});
  
  
  // 曜日設定された薬の服用状況を管理
  Map<String, Map<String, bool>> _weekdayMedicationStatus = {};
  
  // 服用回数別の服用状況を管理（日付 -> メモID -> 回数インデックス -> 服用済み）
  Map<String, Map<String, Map<int, bool>>> _weekdayMedicationDoseStatus = {};
  
  // 服用メモのチェック状況を管理
  Map<String, bool> _medicationMemoStatus = {};
  
  // メモ選択状態を管理
  bool _isMemoSelected = false;
  MedicationMemo? _selectedMemo;
  
  
  // アラームデータを管理
  List<Map<String, dynamic>> _alarmList = [];
  Map<String, dynamic> _alarmSettings = {};
  
  // オーバースクロール検出用の状態変数
  bool _isAtTop = false;
  double _lastScrollPosition = 0.0;
  
  // カレンダータブのスクロール制御用
  final ScrollController _calendarScrollController = ScrollController();
  
  // 服用履歴メモ用のScrollController
  final ScrollController _medicationHistoryScrollController = ScrollController();
  
  // 服用記録ページめくり用のコントローラー
  late PageController _medicationPageController;
  int _currentMedicationPage = 0;
  
  // カレンダー下の位置を取得するためのGlobalKey
  final GlobalKey _calendarBottomKey = GlobalKey();
  
  // スクロールバトンタッチ用の変数
  bool _isScrollBatonPassActive = false;
  
  // ログ制御用の変数
  DateTime _lastAlarmCheckLog = DateTime.now();
  
  // カレンダー色変更用の変数
  Map<String, Color> _dayColors = {};
  static const Duration _logInterval = Duration(seconds: 30); // 30秒間隔でログ出力
  
  // ログ出力を制限するヘルパーメソッド
  bool _shouldLog() {
    final now = DateTime.now();
    if (now.difference(_lastAlarmCheckLog) >= _logInterval) {
      _lastAlarmCheckLog = now;
      return true;
    }
    return false;
  }
  
  
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 4, vsync: this);
    _tabController.addListener(() {
      setState(() {});
    });
    // ✅ SnapshotServiceにスナップショット保存関数を登録
    SnapshotService.register((label) => _saveSnapshotBeforeChange(label));
    
   
    
    // PageControllerを初期化
    _medicationPageController = PageController(viewportFraction: 1.0);
    // ValueNotifier初期値
    _memoTextNotifier.value = '';
    _dayColorsNotifier.value = Map<String, Color>.from(_dayColors);
    
    // ページネーション初期化
    _initializeScrollListener();
      
    // ✅ 修正：データ読み込みを確実に実行
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      debugPrint('🔄 データ読み込み開始...');
      
      try {
        // 1. 全データを読み込み
        await _loadSavedData();
        debugPrint('✅ 全データ読み込み完了');
        
        // 2. 服用メモを明示的に読み込み（確実に実行）
        await _loadMedicationMemosWithRetry();
        debugPrint('✅ 服用メモ読み込み完了: ${_medicationMemos.length}件');
        
        // 3. ページネーション初期化
        _currentPage = 0;
        _displayedMemos.clear();
        _loadMoreMemos();
        debugPrint('✅ ページネーション初期化完了');
        
        // 4. 基本設定
        if (_selectedDay == null) {
          _selectedDay = DateTime.now();
        }
        if (_selectedDates.isEmpty) {
          _selectedDates.add(_normalizeDate(DateTime.now()));
        }
        _setupControllerListeners();
        
        // 5. 初期化完了フラグを設定（最後に設定）
      _isInitialized = true;
      
        // 6. UIを強制更新
        if (mounted) {
          setState(() {
            debugPrint('✅ UI更新完了');
          });
        }
        
        debugPrint('✅ 初期化完了: メモ${_medicationMemos.length}件');
      } catch (e, stackTrace) {
        debugPrint('❌ 初期化エラー: $e');
        debugPrint('スタックトレース: $stackTrace');
        
        // エラー時も初期化完了フラグを設定（アプリが動作するようにする）
        _isInitialized = true;
      if (mounted) {
        setState(() {});
        }
      }
    });
  }
  
  // 包括的データ読み込みシステム：すべてのデータを復元
  Future<void> _loadSavedData() async {
    try {
      // 包括的データ読み込み：すべてのデータを復元
      await _loadAllData();
      
      // 重い処理も実行
      await _initializeAsync();
      
      // アラームの再登録
      await _reRegisterAlarms();
      
      // データ保持テスト
      await _testDataPersistence();
      
      // ✅ 自動バックアップ機能を初期化
      _initializeAutoBackup();
      
      _debugLog('全データ読み込み完了（包括的ローカル復元）');
    } catch (e) {
      _debugLog('データ読み込みエラー: $e');
    }
  }
  
  // 包括的データ保存システム：すべてのデータをローカル保存
  Future<void> _saveAllData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // 1. メモ状態の保存
      await _saveMemoStatus();
      
      // 2. 服用薬データの保存
      await _saveMedicationList();
      
      // 3. アラームデータの保存
      await _saveAlarmData();
      
      // 4. カレンダーマークの保存
      await _saveCalendarMarks();
      
      // 5. ユーザー設定の保存
      await _saveUserPreferences();
      
      // 6. 服用データの保存
      await _saveMedicationData();
      
      // 7. 日別色設定の保存
      await _saveDayColors();
      
      // 8. 統計データの保存
      await _saveStatistics();
      
      // 9. アプリ設定の保存
      await _saveAppSettings();
      
      // 10. 服用回数別状態の保存
      await _saveMedicationDoseStatus();
      
      _debugLog('全データ保存完了（包括的ローカル保存）');
      
      // ✅ 操作時間を記録（手動復元用）
      _lastOperationTime = DateTime.now();
      
      // ✅ 操作スナップショットを常に保存（5分以降でも手動復元可能）
      try {
        final backupData = await _createSafeBackupData('操作スナップショット');
        final jsonString = await _safeJsonEncode(backupData);
        final encryptedData = await _encryptDataAsync(jsonString);
        final snapshotKey = 'operation_snapshot_latest';
        await prefs.setString(snapshotKey, encryptedData);
        await _updateBackupHistory('操作スナップショット', snapshotKey, type: 'snapshot');
        await prefs.setString('last_snapshot_key', snapshotKey);
      } catch (e) {
        debugPrint('操作スナップショット保存エラー: $e');
      }
    } catch (e) {
      _debugLog('全データ保存エラー: $e');
    }
  }
  
  // ✅ 自動バックアップ機能の初期化
  void _initializeAutoBackup() {
    _scheduleAutoBackup();
    debugPrint('🔄 自動バックアップ機能を初期化しました');
  }
  
  // ✅ 深夜2:00の自動バックアップをスケジュール
  void _scheduleAutoBackup() {
    _autoBackupTimer?.cancel();
    
    final now = DateTime.now();
    // 次の実行時刻を当日20:12（過ぎていれば翌日20:12）に設定
    final todayTarget = DateTime(now.year, now.month, now.day, 20, 12);
    final nextRun = now.isBefore(todayTarget)
        ? todayTarget
        : DateTime(now.year, now.month, now.day + 1, 20, 12);
    final duration = nextRun.difference(now);
    
    _autoBackupTimer = Timer(duration, () async {
      if (_autoBackupEnabled) {
        await _performAutoBackup();
        // 次の日の深夜2:00をスケジュール
        _scheduleAutoBackup();
      }
    });
    
    debugPrint('🔄 自動バックアップをスケジュールしました: ${nextRun.toString()}');
  }
  
  // ✅ 自動バックアップを実行
  Future<void> _performAutoBackup() async {
    try {
      final backupName = '自動バックアップ_${DateFormat('yyyy-MM-dd').format(DateTime.now())}';
      debugPrint('🔄 自動バックアップを実行: $backupName');
      
      // バックアップデータを作成
      final backupData = await _createSafeBackupData(backupName);
      final jsonString = await _safeJsonEncode(backupData);
      final encryptedData = await _encryptDataAsync(jsonString);
      
      // バックアップを保存
      final prefs = await SharedPreferences.getInstance();
      final backupKey = 'auto_backup_${DateTime.now().millisecondsSinceEpoch}';
      await prefs.setString(backupKey, encryptedData);
      
      // 履歴を更新（フルとして扱う）
      await _updateBackupHistory(backupName, backupKey, type: 'full');
      
      // 最新バックアップ参照キーを保存
      await prefs.setString('last_auto_backup_key', backupKey);
      await prefs.setString('last_full_backup_key', backupKey);
      
      debugPrint('✅ 自動バックアップ完了: $backupName');
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('🔄 深夜2:00の自動バックアップが完了しました'),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    } catch (e) {
      debugPrint('❌ 自動バックアップエラー: $e');
    }
  }
  
  // ✅ 操作後5分以内の手動復元機能
  Future<void> _showManualRestoreDialog() async {
    if (!mounted) return;
    
    final now = DateTime.now();
    final canRestore = _lastOperationTime != null && 
        now.difference(_lastOperationTime!).inMinutes <= 5;
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.restore, color: Colors.blue),
            SizedBox(width: 8),
            Text('手動復元'),
          ],
        ),
        content: SizedBox(
          width: double.maxFinite,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: canRestore ? Colors.green.withOpacity(0.1) : Colors.orange.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  canRestore 
                    ? '✅ 操作後5分以内です\n最後の操作から${now.difference(_lastOperationTime!).inMinutes}分経過'
                    : '⚠️ 操作後5分を過ぎています\n最後の操作から${_lastOperationTime != null ? now.difference(_lastOperationTime!).inMinutes : 0}分経過',
                  style: const TextStyle(fontSize: 14),
                ),
              ),
              const SizedBox(height: 16),
              if (canRestore) ...[
                ElevatedButton.icon(
                  onPressed: () async {
                    Navigator.of(context).pop();
                    await _performManualRestore();
                  },
                  icon: const Icon(Icons.restore),
                  label: const Text('操作前の状態に復元'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue,
                    foregroundColor: Colors.white,
                  ),
                ),
              ] else ...[
                const Text(
                  '操作後5分以内に復元ボタンを押してください',
                  style: TextStyle(color: Colors.orange),
                  textAlign: TextAlign.center,
                ),
              ],
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('閉じる'),
          ),
        ],
      ),
    );
  }
  
  // ✅ 手動復元を実行
  Future<void> _performManualRestore() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      // ✅ 操作スナップショット（直近保存時に常に更新）を参照
      final lastBackupKey = prefs.getString('last_snapshot_key');
      
      if (lastBackupKey != null) {
        debugPrint('🔄 手動復元を実行: $lastBackupKey');
        await _restoreBackup(lastBackupKey);
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('🔄 操作前の状態に復元しました'),
              backgroundColor: Colors.blue,
              duration: Duration(seconds: 3),
            ),
          );
        }
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('❌ 復元可能なスナップショットが見つかりません'),
              backgroundColor: Colors.red,
              duration: Duration(seconds: 3),
            ),
          );
        }
      }
    } catch (e) {
      debugPrint('❌ 手動復元エラー: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('❌ 復元エラー: $e'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }
  
  // 包括的データ読み込みシステム：すべてのデータを復元
  Future<void> _loadAllData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // 1. メモ状態の読み込み
      await _loadMemoStatus();
      
      // 2. 服用薬データの読み込み
      await _loadMedicationList();
      
      // 3. アラームデータの読み込み
      await _loadAlarmData();
      
      // 3.5. アラームの再登録
      await _reRegisterAlarms();
      
      // 4. カレンダーマークの読み込み
      await _loadCalendarMarks();
      
      // 5. ユーザー設定の読み込み
      await _loadUserPreferences();
      
      // 6. 服用データの読み込み
      await _loadMedicationData();
      
      // 7. 日別色設定の読み込み
      await _loadDayColors();
      
      // 8. 統計データの読み込み
      await _loadStatistics();
      
      // 9. 服用回数別状態の読み込み
      await _loadMedicationDoseStatus();
      
      // 9. アプリ設定の読み込み
      await _loadAppSettings();
      
      // 10. データ検証とUI更新
      await _validateAndUpdateUI();
      
      _debugLog('全データ読み込み完了（包括的ローカル復元）');
    } catch (e) {
      _debugLog('全データ読み込みエラー: $e');
    }
  }
  
  // データ検証とUI更新
  Future<void> _validateAndUpdateUI() async {
    try {
      // データの整合性をチェック
      await _validateDataIntegrity();
      
      // UIを強制更新
      if (mounted) {
        setState(() {
          // 状態を強制更新
        });
      }
      
      // カレンダーの日付を更新
      await _updateCalendarForSelectedDate();
      
      // 服用メモの状態を更新
      await _updateMedicationMemoDisplay();
      
      // アラームデータの検証
      await _validateAlarmData();
      
      // アラームデータの整合性チェック
      await _checkAlarmDataIntegrity();
      
      // アプリ再起動時のデータ表示を確実にする
      await _ensureDataDisplayOnRestart();
      
      // 最終的なデータ表示確認
      await _finalDataDisplayCheck();
      
      _debugLog('データ検証とUI更新完了');
    } catch (e) {
      _debugLog('データ検証とUI更新エラー: $e');
    }
  }
  
  // 最終的なデータ表示確認
  Future<void> _finalDataDisplayCheck() async {
    try {
      // データ表示の最終確認
      debugPrint('=== 最終データ表示確認 ===');
      debugPrint('選択日付: ${_selectedDay != null ? DateFormat('yyyy-MM-dd').format(_selectedDay!) : 'なし'}');
      debugPrint('服用メモ数: ${_medicationMemos.length}件');
      debugPrint('メモ状態数: ${_medicationMemoStatus.length}件');
      debugPrint('動的薬リスト数: ${_addedMedications.length}件');
      debugPrint('カレンダーマーク数: ${_selectedDates.length}件');
      debugPrint('日別色設定数: ${_dayColors.length}件');
      
      // UIを最終更新
      if (mounted) {
        setState(() {
          // 最終的なUI更新
        });
      }
      
      debugPrint('=== 最終データ表示確認完了 ===');
    } catch (e) {
      debugPrint('最終データ表示確認エラー: $e');
    }
  }
  
  // データの整合性をチェック
  Future<void> _validateDataIntegrity() async {
    try {
      // 選択された日付のデータを確認
      if (_selectedDay != null) {
        final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
        final dayData = _medicationData[dateStr];
        
        if (dayData != null) {
          debugPrint('選択日付のデータ確認: $dateStr - ${dayData.length}件');
        } else {
          debugPrint('選択日付のデータなし: $dateStr');
        }
      }
      
      // 服用メモの状態を確認
      debugPrint('服用メモ状態: ${_medicationMemoStatus.length}件');
      
      // カレンダーマークを確認
      debugPrint('カレンダーマーク: ${_selectedDates.length}件');
      
      // 日別色設定を確認
      debugPrint('日別色設定: ${_dayColors.length}件');
      
    } catch (e) {
      debugPrint('データ整合性チェックエラー: $e');
    }
  }
  
  // カレンダーの日付を更新
  Future<void> _updateCalendarForSelectedDate() async {
    try {
      if (_selectedDay != null) {
        // 選択された日付のデータを読み込み
        await _updateMedicineInputsForSelectedDate();
        
        // メモを読み込み
        await _loadMemoForSelectedDate();
        
        debugPrint('カレンダー日付更新完了: ${DateFormat('yyyy-MM-dd').format(_selectedDay!)}');
      }
    } catch (e) {
      debugPrint('カレンダー日付更新エラー: $e');
    }
  }
  
  // 服用メモの表示を更新
  Future<void> _updateMedicationMemoDisplay() async {
    try {
      // 服用メモの状態を再計算
      for (final memo in _medicationMemos) {
        if (!_medicationMemoStatus.containsKey(memo.id)) {
          _medicationMemoStatus[memo.id] = false;
        }
      }
      
      debugPrint('服用メモ表示更新完了: ${_medicationMemos.length}件');
    } catch (e) {
      debugPrint('服用メモ表示更新エラー: $e');
    }
  }
  
  // 🔴 最重要：データ保持テスト（完全版）
  Future<void> _testDataPersistence() async {
    try {
      // 🔴 最重要：最小構成テンプレート
      final testKey = 'flutter_storage_test';
      final testValue = 'data_persistence_test_${DateTime.now().millisecondsSinceEpoch}';
      
      debugPrint('🔴 データ保持テスト開始: $testValue');
      
      // 🔴 最重要：保存処理（awaitを確実に付ける）
      await AppPreferences.saveString(testKey, testValue);
      debugPrint('🔴 データ保持テスト保存完了（完全版）');
      
      // 🔴 最重要：復元処理（起動時）
      final readValue = AppPreferences.getString(testKey);
      if (readValue == testValue) {
        debugPrint('🔴 データ保持テスト成功: $readValue（完全版）');
      } else {
        debugPrint('🔴 データ保持テスト失敗: 期待値=$testValue, 実際値=$readValue');
      }
      
      // 🔴 最重要：デバッグ用：すべてのキーを表示
      AppPreferences.debugAllKeys();
      
      // テストデータの削除
      await AppPreferences.remove(testKey);
      debugPrint('🔴 テストデータ削除完了');
    } catch (e) {
      debugPrint('🔴 データ保持テストエラー: $e');
    }
  }
  
  // 服用データの読み込み
  Future<void> _loadMedicationData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastSaveDate = prefs.getString('last_save_date');
      
      if (lastSaveDate != null) {
        final backupData = prefs.getString('medication_backup_$lastSaveDate');
        if (backupData != null) {
          final dataJson = jsonDecode(backupData) as Map<String, dynamic>;
          debugPrint('服用データ復元: $lastSaveDate');
        }
      }
    } catch (e) {
      debugPrint('服用データ読み込みエラー: $e');
    }
  }
  
  // こぱさん流：服用薬データを読み込み（確実なデータ復元）
  Future<void> _loadMedicationList() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      String? medicationListStr;
      
      // こぱさん流：複数キーから読み込み
      final keys = ['medicationList', 'medicationList_backup'];
      
      for (final key in keys) {
        medicationListStr = prefs.getString(key);
        if (medicationListStr != null && medicationListStr.isNotEmpty) {
          debugPrint('服用薬データ読み込み成功: $key（こぱさん流）');
          break;
        }
      }
      
      if (medicationListStr != null && medicationListStr.isNotEmpty) {
        final medicationListJson = jsonDecode(medicationListStr) as Map<String, dynamic>;
        _addedMedications.clear();
        
        final count = prefs.getInt('medicationList_count') ?? 0;
        for (int i = 0; i < count; i++) {
          final medKey = 'medication_$i';
          if (medicationListJson.containsKey(medKey)) {
            final medData = medicationListJson[medKey] as Map<String, dynamic>;
            _addedMedications.add({
              'id': medData['id'],
              'name': medData['name'],
              'type': medData['type'],
              'dosage': medData['dosage'],
              'color': medData['color'],
              'taken': medData['taken'],
              'takenTime': medData['takenTime'] != null ? DateTime.parse(medData['takenTime']) : null,
              'notes': medData['notes'],
            });
          }
        }
        
        debugPrint('服用薬データ読み込み完了: ${_addedMedications.length}件（こぱさん流）');
        
        // こぱさん流：UIに反映
        if (mounted) {
          setState(() {
            // 保存された値があればそれを使う
          });
        }
      } else {
        debugPrint('服用薬データが見つかりません（こぱさん流）');
        _addedMedications.clear();
      }
    } catch (e) {
      debugPrint('服用薬データ読み込みエラー: $e');
      _addedMedications.clear();
    }
  }
  
  // 確実なアラームデータ読み込み（指定パス方式を採用）
  Future<void> _loadAlarmData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final alarmCount = prefs.getInt('alarm_count') ?? 0;
      final alarmsList = <Map<String, dynamic>>[];
      
      debugPrint('アラームデータ読み込み開始: $alarmCount件');
      
      for (int i = 0; i < alarmCount; i++) {
        final name = prefs.getString('alarm_${i}_name');
        final time = prefs.getString('alarm_${i}_time');
        final repeat = prefs.getString('alarm_${i}_repeat');
        final enabled = prefs.getBool('alarm_${i}_enabled');
        final alarmType = prefs.getString('alarm_${i}_alarmType');
        final volume = prefs.getInt('alarm_${i}_volume');
        final message = prefs.getString('alarm_${i}_message');
        
        if (name != null && time != null) {
          alarmsList.add({
            'name': name,
            'time': time,
            'repeat': repeat ?? '一度だけ',
            'enabled': enabled ?? true,
            'alarmType': alarmType ?? 'sound',
            'volume': volume ?? 80,
            'message': message ?? '薬を服用する時間です',
          });
        }
      }
      
      setState(() {
        _alarmList = alarmsList;
      });
      
      debugPrint('アラームデータ読み込み完了: ${_alarmList.length}件（指定パス方式）');
      
      // UIを更新
      if (mounted) {
        setState(() {
          // アラームデータを反映
        });
      }
    } catch (e) {
      debugPrint('アラームデータ読み込みエラー: $e');
      _alarmList = [];
    }
  }
  
  // こぱさん流：アラームの再登録
  Future<void> _reRegisterAlarms() async {
    try {
      if (_alarmList.isEmpty) {
        debugPrint('アラーム再登録: アラームデータなし');
        return;
      }
      
      debugPrint('アラーム再登録開始: ${_alarmList.length}件');
      
      // 既存の通知をキャンセル
      // await NotificationService.cancelAllNotifications();
      
      // 各アラームを再登録
      for (int i = 0; i < _alarmList.length; i++) {
        final alarm = _alarmList[i];
        await _registerSingleAlarm(alarm, i);
      }
      
      debugPrint('アラーム再登録完了: ${_alarmList.length}件');
    } catch (e) {
      debugPrint('アラーム再登録エラー: $e');
    }
  }
  
  // 単一アラームの登録
  Future<void> _registerSingleAlarm(Map<String, dynamic> alarm, int index) async {
    try {
      // アラームの詳細情報を取得（安全な型変換）
      final time = alarm['time']?.toString() ?? '09:00';
      final enabled = alarm['enabled'] is bool ? alarm['enabled'] as bool : true;
      final title = alarm['title']?.toString() ?? '服用アラーム';
      final message = alarm['message']?.toString() ?? '薬を服用する時間です';
      
      if (!enabled) {
        debugPrint('アラーム $index は無効化されています');
        return;
      }
      
      // 時間を解析
      final timeParts = time.split(':');
      final hour = int.parse(timeParts[0]);
      final minute = int.parse(timeParts[1]);
      
      // 今日の日時を設定
      final now = DateTime.now();
      var scheduledTime = DateTime(now.year, now.month, now.day, hour, minute);
      
      // 過去の時間の場合は明日に設定
      if (scheduledTime.isBefore(now)) {
        scheduledTime = scheduledTime.add(const Duration(days: 1));
      }
      
      // 通知をスケジュール
      // await NotificationService.scheduleNotification(
      //   id: index,
      //   title: title,
      //   body: message,
      //   scheduledTime: scheduledTime,
      // );
      
      debugPrint('アラーム $index 登録完了: $time');
    } catch (e) {
      debugPrint('アラーム $index 登録エラー: $e');
    }
  }
  
  // アラームの追加（指定パス方式）
  Future<void> addAlarm(Map<String, dynamic> alarm) async {
    try {
      // ✅ 追加：変更前スナップショット
      await _saveSnapshotBeforeChange('アラーム追加_${alarm['name']}');
      setState(() {
        _alarmList.add(alarm);
      });
      
      // アラーム追加後に自動保存
      await _saveAlarmData();
      
      // 新しいアラームを登録
      await _registerSingleAlarm(alarm, _alarmList.length - 1);
      
      debugPrint('アラーム追加完了: ${alarm['name']}');
    } catch (e) {
      debugPrint('アラーム追加エラー: $e');
    }
  }
  
  // アラームの削除（指定パス方式）
  Future<void> removeAlarm(int index) async {
    try {
      if (index >= 0 && index < _alarmList.length) {
        // ✅ 追加：変更前スナップショット
        final alarm = _alarmList[index];
        await _saveSnapshotBeforeChange('アラーム削除_${alarm['name']}');
        setState(() {
          _alarmList.removeAt(index);
        });
        
        // アラーム削除後に自動保存
        await _saveAlarmData();
        
        debugPrint('アラーム削除完了: インデックス $index');
      }
    } catch (e) {
      debugPrint('アラーム削除エラー: $e');
    }
  }
  
  // アラームの更新（指定パス方式）
  Future<void> updateAlarm(int index, Map<String, dynamic> updatedAlarm) async {
    try {
      if (index >= 0 && index < _alarmList.length) {
        // ✅ 追加：変更前スナップショット
        final alarm = _alarmList[index];
        await _saveSnapshotBeforeChange('アラーム編集_${alarm['name']}');
        setState(() {
          _alarmList[index] = updatedAlarm;
        });
        
        // アラーム更新後に自動保存
        await _saveAlarmData();
        
        debugPrint('アラーム更新完了: インデックス $index');
      }
    } catch (e) {
      debugPrint('アラーム更新エラー: $e');
    }
  }
  
  // アラームの有効/無効切り替え（指定パス方式）
  Future<void> toggleAlarm(int index) async {
    try {
      if (index >= 0 && index < _alarmList.length) {
        final alarm = _alarmList[index];
        final newEnabled = !(alarm['enabled'] as bool? ?? true);
        
        // ✅ 追加：変更前スナップショット
        await _saveSnapshotBeforeChange('アラーム切替_${alarm['name']}_${newEnabled ? '有効' : '無効'}');
        setState(() {
          alarm['enabled'] = newEnabled;
        });
        
        // アラーム切り替え後に自動保存
        await _saveAlarmData();
        
        debugPrint('アラーム切り替え完了: インデックス $index, 有効=$newEnabled');
      }
    } catch (e) {
      debugPrint('アラーム切り替えエラー: $e');
    }
  }
  
  // アラームデータの検証
  Future<void> _validateAlarmData() async {
    try {
      debugPrint('=== アラームデータ検証 ===');
      debugPrint('アラーム数: ${_alarmList.length}件');
      
      for (int i = 0; i < _alarmList.length; i++) {
        final alarm = _alarmList[i];
        debugPrint('アラーム $i:');
        debugPrint('  タイトル: ${alarm['title'] ?? 'なし'}');
        debugPrint('  時間: ${alarm['time'] ?? 'なし'}');
        debugPrint('  有効: ${alarm['enabled'] ?? false}');
        debugPrint('  メッセージ: ${alarm['message'] ?? 'なし'}');
      }
      
      debugPrint('アラーム設定: ${_alarmSettings.length}件');
      for (final entry in _alarmSettings.entries) {
        debugPrint('  ${entry.key}: ${entry.value}');
      }
      
      debugPrint('=== アラームデータ検証完了 ===');
    } catch (e) {
      debugPrint('アラームデータ検証エラー: $e');
    }
  }
  
  // アラームデータの整合性チェック
  Future<void> _checkAlarmDataIntegrity() async {
    try {
      // アラームデータの整合性をチェック
      for (int i = 0; i < _alarmList.length; i++) {
        final alarm = _alarmList[i];
        
        // 必須フィールドのチェック
        if (!alarm.containsKey('title') || alarm['title'] == null) {
          alarm['title'] = '服用アラーム';
        }
        if (!alarm.containsKey('time') || alarm['time'] == null) {
          alarm['time'] = '09:00';
        }
        if (!alarm.containsKey('enabled') || alarm['enabled'] == null) {
          alarm['enabled'] = true;
        }
        if (!alarm.containsKey('message') || alarm['message'] == null) {
          alarm['message'] = '薬を服用する時間です';
        }
      }
      
      // データを再保存
      await _saveAlarmData();
      
      debugPrint('アラームデータ整合性チェック完了');
    } catch (e) {
      debugPrint('アラームデータ整合性チェックエラー: $e');
    }
  }
  
  // カレンダーマークの保存
  Future<void> _saveCalendarMarks() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final marksJson = <String, dynamic>{};
      
      // 選択された日付を保存
      for (final date in _selectedDates) {
        marksJson[date.toIso8601String()] = {
          'date': date.toIso8601String(),
          'hasData': _addedMedications.isNotEmpty,
          'medicationCount': _addedMedications.length,
        };
      }
      
      final success1 = await prefs.setString('calendar_marks', jsonEncode(marksJson));
      final success2 = await prefs.setString('calendar_marks_backup', jsonEncode(marksJson));
      final success3 = await prefs.setInt('calendar_marks_count', _selectedDates.length);
      
      if (success1 && success2 && success3) {
        debugPrint('カレンダーマーク保存完了: ${_selectedDates.length}件');
      } else {
        debugPrint('カレンダーマーク保存に失敗');
      }
    } catch (e) {
      debugPrint('カレンダーマーク保存エラー: $e');
    }
  }
  
  // カレンダーマークの読み込み
  Future<void> _loadCalendarMarks() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      String? marksStr;
      
      final keys = ['calendar_marks', 'calendar_marks_backup'];
      
      for (final key in keys) {
        try {
          marksStr = prefs.getString(key);
          if (marksStr != null && marksStr.isNotEmpty) {
            debugPrint('カレンダーマーク読み込み成功: $key');
            break;
          }
        } catch (e) {
          debugPrint('キー $key の読み込みエラー: $e');
          continue;
        }
      }
      
      if (marksStr != null && marksStr.isNotEmpty) {
        try {
          final marksJson = jsonDecode(marksStr) as Map<String, dynamic>;
          _selectedDates.clear();
          
          for (final entry in marksJson.entries) {
            final dateStr = entry.key;
            final date = DateTime.parse(dateStr);
            _selectedDates.add(_normalizeDate(date));
          }
          
          debugPrint('カレンダーマーク読み込み完了: ${_selectedDates.length}件');
        } catch (e) {
          debugPrint('カレンダーマークJSONデコードエラー: $e');
          _selectedDates.clear();
        }
      } else {
        debugPrint('カレンダーマークが見つかりません');
        _selectedDates.clear();
      }
    } catch (e) {
      debugPrint('カレンダーマーク読み込みエラー: $e');
      _selectedDates.clear();
    }
  }
  
  // ユーザー設定の保存
  Future<void> _saveUserPreferences() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final preferencesJson = <String, dynamic>{
        'selectedDay': _selectedDay?.toIso8601String(),
        'isMemoSelected': _isMemoSelected,
        'selectedMemoId': _selectedMemo?.id,
        'isAlarmPlaying': _isAlarmPlaying,
        'notificationError': _notificationError,
        'lastSaveTime': DateTime.now().toIso8601String(),
      };
      
      final success1 = await prefs.setString('user_preferences', jsonEncode(preferencesJson));
      final success2 = await prefs.setString('user_preferences_backup', jsonEncode(preferencesJson));
      
      if (success1 && success2) {
        debugPrint('ユーザー設定保存完了');
      } else {
        debugPrint('ユーザー設定保存に失敗');
      }
    } catch (e) {
      debugPrint('ユーザー設定保存エラー: $e');
    }
  }
  
  // ユーザー設定の読み込み
  Future<void> _loadUserPreferences() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      String? preferencesStr;
      
      final keys = ['user_preferences', 'user_preferences_backup'];
      
      for (final key in keys) {
        try {
          preferencesStr = prefs.getString(key);
          if (preferencesStr != null && preferencesStr.isNotEmpty) {
            debugPrint('ユーザー設定読み込み成功: $key');
            break;
          }
        } catch (e) {
          debugPrint('キー $key の読み込みエラー: $e');
          continue;
        }
      }
      
      if (preferencesStr != null && preferencesStr.isNotEmpty) {
        try {
          final preferencesJson = jsonDecode(preferencesStr) as Map<String, dynamic>;
          
          if (preferencesJson['selectedDay'] != null) {
            _selectedDay = DateTime.parse(preferencesJson['selectedDay']);
          }
          
          _isMemoSelected = preferencesJson['isMemoSelected'] ?? false;
          _isAlarmPlaying = preferencesJson['isAlarmPlaying'] ?? false;
          _notificationError = preferencesJson['notificationError'] ?? false;
          
          debugPrint('ユーザー設定読み込み完了');
        } catch (e) {
          debugPrint('ユーザー設定JSONデコードエラー: $e');
        }
      } else {
        debugPrint('ユーザー設定が見つかりません');
      }
    } catch (e) {
      debugPrint('ユーザー設定読み込みエラー: $e');
    }
  }
  
  // 日別色設定の保存
  Future<void> _saveDayColors() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final colorsJson = <String, dynamic>{};
      
      for (final entry in _dayColors.entries) {
        colorsJson[entry.key] = entry.value.value;
      }
      
      final success1 = await prefs.setString('day_colors', jsonEncode(colorsJson));
      final success2 = await prefs.setString('day_colors_backup', jsonEncode(colorsJson));
      
      if (success1 && success2) {
        debugPrint('日別色設定保存完了: ${_dayColors.length}件');
      } else {
        debugPrint('日別色設定保存に失敗');
      }
    } catch (e) {
      debugPrint('日別色設定保存エラー: $e');
    }
  }
  
  // 日別色設定の読み込み
  Future<void> _loadDayColors() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      String? colorsStr;
      
      final keys = ['day_colors', 'day_colors_backup'];
      
      for (final key in keys) {
        try {
          colorsStr = prefs.getString(key);
          if (colorsStr != null && colorsStr.isNotEmpty) {
            debugPrint('日別色設定読み込み成功: $key');
            break;
          }
        } catch (e) {
          debugPrint('キー $key の読み込みエラー: $e');
          continue;
        }
      }
      
      if (colorsStr != null && colorsStr.isNotEmpty) {
        try {
          final Map<String, dynamic> decoded = jsonDecode(colorsStr);
          _dayColors = decoded.map((key, value) => MapEntry(key, Color(value)));
          debugPrint('日別色設定読み込み完了: ${_dayColors.length}件');
        } catch (e) {
          debugPrint('日別色設定JSONデコードエラー: $e');
          _dayColors = {};
        }
      } else {
        debugPrint('日別色設定が見つかりません');
        _dayColors = {};
      }
    } catch (e) {
      debugPrint('日別色設定読み込みエラー: $e');
      _dayColors = {};
    }
  }
  
  // 統計データの保存
  Future<void> _saveStatistics() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final statisticsJson = <String, dynamic>{
        'adherenceRates': _adherenceRates,
        'totalMedications': _addedMedications.length,
        'lastCalculation': DateTime.now().toIso8601String(),
      };
      
      final success1 = await prefs.setString('statistics', jsonEncode(statisticsJson));
      final success2 = await prefs.setString('statistics_backup', jsonEncode(statisticsJson));
      
      if (success1 && success2) {
        debugPrint('統計データ保存完了');
      } else {
        debugPrint('統計データ保存に失敗');
      }
    } catch (e) {
      debugPrint('統計データ保存エラー: $e');
    }
  }
  
  // 統計データの読み込み
  Future<void> _loadStatistics() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      String? statisticsStr;
      
      final keys = ['statistics', 'statistics_backup'];
      
      for (final key in keys) {
        try {
          statisticsStr = prefs.getString(key);
          if (statisticsStr != null && statisticsStr.isNotEmpty) {
            debugPrint('統計データ読み込み成功: $key');
            break;
          }
        } catch (e) {
          debugPrint('キー $key の読み込みエラー: $e');
          continue;
        }
      }
      
      if (statisticsStr != null && statisticsStr.isNotEmpty) {
        try {
          final statisticsJson = jsonDecode(statisticsStr) as Map<String, dynamic>;
          _adherenceRates = Map<String, double>.from(statisticsJson['adherenceRates'] ?? {});
          debugPrint('統計データ読み込み完了');
        } catch (e) {
          debugPrint('統計データJSONデコードエラー: $e');
          _adherenceRates = {};
        }
      } else {
        debugPrint('統計データが見つかりません');
        _adherenceRates = {};
      }
    } catch (e) {
      debugPrint('統計データ読み込みエラー: $e');
      _adherenceRates = {};
    }
  }
  
  // アプリ設定の保存
  Future<void> _saveAppSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final settingsJson = <String, dynamic>{
        'appVersion': '1.0.1',
        'lastUpdate': DateTime.now().toIso8601String(),
        'dataVersion': 'flutter_3_29_3',
        'backupEnabled': true,
      };
      
      final success1 = await prefs.setString('app_settings', jsonEncode(settingsJson));
      final success2 = await prefs.setString('app_settings_backup', jsonEncode(settingsJson));
      
      if (success1 && success2) {
        debugPrint('アプリ設定保存完了');
      } else {
        debugPrint('アプリ設定保存に失敗');
      }
    } catch (e) {
      debugPrint('アプリ設定保存エラー: $e');
    }
  }
  
  // 服用回数別状態の保存
  Future<void> _saveMedicationDoseStatus() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final doseStatusJson = <String, dynamic>{};
      
      for (final dateEntry in _weekdayMedicationDoseStatus.entries) {
        final dateStr = dateEntry.key;
        final memoStatus = dateEntry.value;
        final memoStatusJson = <String, dynamic>{};
        
        for (final memoEntry in memoStatus.entries) {
          final memoId = memoEntry.key;
          final doseStatus = memoEntry.value;
          final doseStatusJson = <String, dynamic>{};
          
          for (final doseEntry in doseStatus.entries) {
            doseStatusJson[doseEntry.key.toString()] = doseEntry.value;
          }
          
          memoStatusJson[memoId] = doseStatusJson;
        }
        
        doseStatusJson[dateStr] = memoStatusJson;
      }
      
      final success1 = await prefs.setString('medication_dose_status', jsonEncode(doseStatusJson));
      final success2 = await prefs.setString('medication_dose_status_backup', jsonEncode(doseStatusJson));
      
      if (success1 && success2) {
        debugPrint('服用回数別状態保存完了');
      } else {
        debugPrint('服用回数別状態保存に失敗');
      }
    } catch (e) {
      debugPrint('服用回数別状態保存エラー: $e');
    }
  }
  
  // 服用回数別状態の読み込み
  Future<void> _loadMedicationDoseStatus() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final doseStatusStr = prefs.getString('medication_dose_status') ?? 
                           prefs.getString('medication_dose_status_backup') ?? '{}';
      final doseStatusJson = jsonDecode(doseStatusStr) as Map<String, dynamic>;
      
      _weekdayMedicationDoseStatus.clear();
      
      for (final dateEntry in doseStatusJson.entries) {
        final dateStr = dateEntry.key;
        final memoStatus = dateEntry.value as Map<String, dynamic>;
        final memoStatusMap = <String, Map<int, bool>>{};
        
        for (final memoEntry in memoStatus.entries) {
          final memoId = memoEntry.key;
          final doseStatus = memoEntry.value as Map<String, dynamic>;
          final doseStatusMap = <int, bool>{};
          
          for (final doseEntry in doseStatus.entries) {
            doseStatusMap[int.parse(doseEntry.key)] = doseEntry.value as bool;
          }
          
          memoStatusMap[memoId] = doseStatusMap;
        }
        
        _weekdayMedicationDoseStatus[dateStr] = memoStatusMap;
      }
      
      debugPrint('服用回数別状態読み込み完了');
    } catch (e) {
      debugPrint('服用回数別状態読み込みエラー: $e');
    }
  }
  
  // アプリ設定の読み込み
  Future<void> _loadAppSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      String? settingsStr;
      
      final keys = ['app_settings', 'app_settings_backup'];
      
      for (final key in keys) {
        try {
          settingsStr = prefs.getString(key);
          if (settingsStr != null && settingsStr.isNotEmpty) {
            debugPrint('アプリ設定読み込み成功: $key');
            break;
          }
        } catch (e) {
          debugPrint('キー $key の読み込みエラー: $e');
          continue;
        }
      }
      
      if (settingsStr != null && settingsStr.isNotEmpty) {
        try {
          final settingsJson = jsonDecode(settingsStr) as Map<String, dynamic>;
          debugPrint('アプリ設定読み込み完了: ${settingsJson['appVersion']}');
        } catch (e) {
          debugPrint('アプリ設定JSONデコードエラー: $e');
        }
      } else {
        debugPrint('アプリ設定が見つかりません');
      }
    } catch (e) {
      debugPrint('アプリ設定読み込みエラー: $e');
    }
  }
  
  // その他の設定読み込み
  Future<void> _loadOtherSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // 日別の色設定
      final colorsJson = prefs.getString('day_colors');
      if (colorsJson != null) {
        final Map<String, dynamic> decoded = jsonDecode(colorsJson);
        _dayColors = decoded.map((key, value) => MapEntry(key, Color(value)));
      }
      
      debugPrint('その他設定読み込み完了');
    } catch (e) {
      debugPrint('その他設定読み込みエラー: $e');
    }
  }
  void _setupControllerListeners() {
    // 動的薬リストのリスナー設定は不要
  }
  
  /// 軽量な初期化処理（アプリ起動を阻害しない）
  Future<void> _initializeAsync() async {
    try {
      // 重複初期化を防ぐ
      if (_isInitialized) {
        debugPrint('初期化済みのためスキップ');
        return;
      }
      
      // 軽量な初期化のみ実行
      _notificationError = !await NotificationService.initialize();
      
      // 重い処理は後回し
      Future.delayed(const Duration(milliseconds: 500), () {
        _loadHeavyData();
      });
      
      debugPrint('軽量初期化完了');
    } catch (e) {
      debugPrint('初期化エラー: $e');
    }
  }
  
  // 重いデータ読み込み（後回し）
  Future<void> _loadHeavyData() async {
    try {
      final futures = await Future.wait([
        MedicationService.loadMedicationData(),
        MedicationService.loadMedicines(),
        MedicationService.loadAdherenceStats(),
        MedicationService.loadSettings(),
      ]);
      
      setState(() {
        _medicationData = futures[0] as Map<String, Map<String, MedicationInfo>>;
        _medicines = futures[1] as List<MedicineData>;
        _adherenceRates = futures[2] as Map<String, double>;
      });
      
      debugPrint('重いデータ読み込み完了');
    } catch (e) {
      debugPrint('重いデータ読み込みエラー: $e');
    }
  }
  
  // SharedPreferencesからバックアップ復元
  Future<void> _loadFromSharedPreferences() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastSaveDate = prefs.getString('last_save_date');
      
      if (lastSaveDate != null) {
        final backupData = prefs.getString('medication_backup_$lastSaveDate');
        if (backupData != null) {
          final dataJson = jsonDecode(backupData) as Map<String, dynamic>;
          debugPrint('バックアップデータ復元: $lastSaveDate');
        }
      }
    } catch (e) {
      debugPrint('バックアップ復元エラー: $e');
    }
  }
  @override
  void dispose() {
    // ✅ 修正：すべてのタイマーとコントローラーを適切に解放
    _debounce?.cancel();
    _debounce = null;
    _saveDebounceTimer?.cancel();
    _saveDebounceTimer = null;
    
    // ✅ 修正：StreamSubscriptionの完全解放
    _subscription?.cancel();
    _subscription = null;
    
    // ✅ 修正：動的薬リストのリスナー解放
    for (final medication in _addedMedications) {
      // 各薬のコントローラーがあれば解放
      if (medication.containsKey('controller')) {
        (medication['controller'] as TextEditingController?)?.dispose();
      }
    }
    
    // ✅ 修正：メモコントローラーとフォーカスノードのクリーンアップ
    _memoController.dispose();
    _memoFocusNode.dispose();
    _tabController.dispose();
    _calendarScrollController.dispose();
    _medicationHistoryScrollController.dispose();
    _statsScrollController.dispose();
    _medicationPageController.dispose();
    _customDaysController.dispose();
    _customDaysFocusNode.dispose();
    
    // ✅ 修正：購入サービスも解放
    InAppPurchaseService.dispose();
    
    // ✅ 修正：Hiveボックスのクリーンアップ
    try {
      Hive.close();
    } catch (e) {
      Logger.warning('Hiveの解放エラー: $e');
    }
    
    super.dispose();
  }
  DateTime _normalizeDate(DateTime date) => DateTime.utc(date.year, date.month, date.day);
  Future<void> _calculateAdherenceStats() async {
    try {
      final now = DateTime.now();
      final stats = <String, double>{};
      for (final period in [7, 30, 90]) {
        int totalDoses = 0;
        int takenDoses = 0;
        for (int i = 0; i < period; i++) {
          final date = now.subtract(Duration(days: i));
          final dateStr = DateFormat('yyyy-MM-dd').format(date);
          final dayData = _medicationData[dateStr];
        
        // 動的薬リストの統計
          if (dayData != null) {
            for (final timeSlot in dayData.values) {
              if (timeSlot.medicine.isNotEmpty) {
                totalDoses++;
                if (timeSlot.checked) takenDoses++;
              }
            }
          }
        
        // 曜日設定された薬の統計（服用メモのチェック状態を反映）
        final weekday = date.weekday % 7; // 0=日曜日, 1=月曜日, ..., 6=土曜日
        final weekdayMemos = _medicationMemos.where((memo) => memo.selectedWeekdays.contains(weekday)).toList();
        
        for (final memo in weekdayMemos) {
          totalDoses++;
          // 服用メモのチェック状態を確認
          if (_medicationMemoStatus[memo.id] == true) {
            takenDoses++;
          }
        }
        }
        stats['$period日間'] = totalDoses > 0 ? (takenDoses / totalDoses * 100) : 0;
      }
      setState(() => _adherenceRates = stats);
      await MedicationService.saveAdherenceStats(stats);
    } catch (e) {
    }
  }
  // ✅ 修正：デバウンス保存の実装
  void _saveCurrentDataDebounced() {
    _saveDebounceTimer?.cancel();
    _saveDebounceTimer = Timer(const Duration(seconds: 2), () {
      _saveCurrentDataDebounced();
    });
  }

  // 強化されたデータ保存メソッド（差分保存対応）
  void _saveCurrentData() async {
    try {
      if (!_isInitialized) return;
      
      // ✅ 修正：変更があった部分のみ保存
      if (_medicationMemoStatusChanged) {
        await _saveMedicationMemoStatus();
        _medicationMemoStatusChanged = false;
      }
      
      if (_weekdayMedicationStatusChanged) {
        await _saveWeekdayMedicationStatus();
        _weekdayMedicationStatusChanged = false;
      }
      
      if (_addedMedicationsChanged) {
      await _saveAddedMedications();
        _addedMedicationsChanged = false;
      }
      
      // 服用メモの保存（Hiveベース）
      for (final memo in _medicationMemos) {
        await AppPreferences.saveMedicationMemo(memo);
      }
      
      // メモの保存
      await _saveMemo();
      
      // 統計の再計算
      await _calculateAdherenceStats();
      
    } catch (e) {
    }
  }
  
  // 動的薬リストの保存
  Future<void> _saveAddedMedications() async {
    try {
      if (_selectedDay == null) return;
      final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
      _medicationData.putIfAbsent(dateStr, () => {});
      
      // 動的薬リストの保存（個別に保存）
      for (final medication in _addedMedications) {
        final key = 'added_medication_${medication.hashCode}';
        _medicationData[dateStr]![key] = MedicationInfo(
          checked: medication['isChecked'] as bool,
          medicine: medication['name'] as String,
          actualTime: medication['isChecked'] as bool ? DateTime.now() : null,
        );
      }
      
      await MedicationService.saveMedicationData(_medicationData);
    } catch (e) {
    }
  }
  
  // 服用メモの状態保存
  Future<void> _saveMedicationMemoStatus() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final memoStatusJson = <String, dynamic>{};
      
      for (final entry in _medicationMemoStatus.entries) {
        memoStatusJson[entry.key] = entry.value;
      }
      
      // ✅ 修正：統一されたキーとバックアップ保存
      final data = jsonEncode(memoStatusJson);
      await prefs.setString(_medicationMemoStatusKey, data);
      await prefs.setString(_medicationMemoStatusKey + _backupSuffix, data);
    } catch (e) {
    }
  }
  
  // 曜日設定薬の状態保存
  Future<void> _saveWeekdayMedicationStatus() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final weekdayStatusJson = <String, dynamic>{};
      
      for (final dateEntry in _weekdayMedicationStatus.entries) {
        weekdayStatusJson[dateEntry.key] = dateEntry.value;
      }
      
      await prefs.setString('weekday_medication_status', jsonEncode(weekdayStatusJson));
    } catch (e) {
    }
  }
  
  // 強化されたデータ読み込みメソッド
  Future<void> _loadCurrentData() async {
    try {
      // 服用メモの状態読み込み
      await _loadMedicationMemoStatus();
      
      // 曜日設定薬の状態読み込み
      await _loadWeekdayMedicationStatus();
      
      // メモの読み込み
      await _loadMemo();
      
    } catch (e) {
    }
  }
  
  // 服用メモの状態読み込み
  Future<void> _loadMedicationMemoStatus() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final memoStatusJson = prefs.getString('medication_memo_status');
      
      if (memoStatusJson != null) {
        final Map<String, dynamic> memoStatusData = jsonDecode(memoStatusJson);
        _medicationMemoStatus.clear();
        
        for (final entry in memoStatusData.entries) {
          _medicationMemoStatus[entry.key] = entry.value as bool;
        }
      }
      
      // 服用メモの初期状態を未チェックに設定
      for (final memo in _medicationMemos) {
        if (!_medicationMemoStatus.containsKey(memo.id)) {
          _medicationMemoStatus[memo.id] = false;
        }
      }
    } catch (e) {
      // エラー時も初期状態を未チェックに設定
      for (final memo in _medicationMemos) {
        _medicationMemoStatus[memo.id] = false;
      }
    }
  }
  
  // 曜日設定薬の状態読み込み
  Future<void> _loadWeekdayMedicationStatus() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final weekdayStatusJson = prefs.getString('weekday_medication_status');
      
      if (weekdayStatusJson != null) {
        final Map<String, dynamic> weekdayStatusData = jsonDecode(weekdayStatusJson);
        _weekdayMedicationStatus.clear();
        
        for (final dateEntry in weekdayStatusData.entries) {
          _weekdayMedicationStatus[dateEntry.key] = Map<String, bool>.from(dateEntry.value);
        }
      }
    } catch (e) {
    }
  }
  
  // メモの読み込み
  Future<void> _loadMemo() async {
    try {
      if (_selectedDay != null) {
        final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
        final prefs = await SharedPreferences.getInstance();
        final memo = prefs.getString('memo_$dateStr');
        if (memo != null) {
          _memoController.text = memo;
        }
      }
    } catch (e) {
    }
  }
  void _onDaySelected(DateTime selectedDay, DateTime focusedDay) async {
    try {
      // トライアル制限チェック（当日以外の選択時）
      final isExpired = await TrialService.isTrialExpired();
      final today = DateTime.now();
      final isToday = selectedDay.year == today.year && 
                      selectedDay.month == today.month && 
                      selectedDay.day == today.day;
      
      if (isExpired && !isToday) {
        showDialog(
          context: context,
          builder: (context) => TrialLimitDialog(featureName: 'カレンダー'),
        );
        return;
      }
      
      // ✅ 修正：先にデータ準備
      final normalizedDay = _normalizeDate(selectedDay);
      final wasSelected = _selectedDates.contains(normalizedDay);
      
      // ✅ 修正：1回のsetStateで全て更新
      setState(() {
        if (wasSelected) {
          _selectedDates.remove(normalizedDay);
            _selectedDay = null;
            _addedMedications.clear();
        } else {
          _selectedDates.add(normalizedDay);
          _selectedDay = normalizedDay;
        }
        _focusedDay = focusedDay;
      });
      
      // ✅ 修正：非同期処理は外で実行
      if (!wasSelected && _selectedDay != null) {
        await _updateMedicineInputsForSelectedDate();
        await _loadCurrentData();
      }
      
      // メモスナップショット保存フラグをリセット
      _memoSnapshotSaved = false;
    } catch (e) {
      _showSnackBar('日付の選択に失敗しました: $e');
    }
  }
  
  
  // カレンダースタイルを動的に生成（日付の色に基づく）
  CalendarStyle _buildCalendarStyle() {
    return CalendarStyle(
      outsideDaysVisible: false,
      cellMargin: const EdgeInsets.all(2),
      cellPadding: const EdgeInsets.all(4),
      cellAlignment: Alignment.center,
      defaultTextStyle: const TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: Colors.white,
      ),
      selectedTextStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: Colors.white,
      ),
      todayTextStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: Colors.white,
      ),
      weekendTextStyle: const TextStyle(
        fontSize: 14,
        fontWeight: FontWeight.w500,
        color: Colors.white,
      ),
      defaultDecoration: BoxDecoration(
        color: Colors.white.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      selectedDecoration: BoxDecoration(
        gradient: const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFFff6b6b),
            Color(0xFFee5a24),
          ],
        ),
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: const Color(0xFFff6b6b).withOpacity(0.3),
            spreadRadius: 1,
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      todayDecoration: BoxDecoration(
        gradient: const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF4ecdc4),
            Color(0xFF44a08d),
          ],
        ),
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: const Color(0xFF4ecdc4).withOpacity(0.3),
            spreadRadius: 1,
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      markersMaxCount: 1,
      markerDecoration: BoxDecoration(
        color: Colors.red,
        shape: BoxShape.circle,
      ),
    );
  }
  
  // カスタム日付装飾を取得
  BoxDecoration? _getCustomDayDecoration(DateTime day) {
    final dateKey = DateFormat('yyyy-MM-dd').format(day);
    final customColor = _dayColors[dateKey];
    
    if (customColor != null) {
      return BoxDecoration(
        color: customColor,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: customColor.withOpacity(0.3),
            spreadRadius: 1,
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      );
    }
    return null;
  }
  
  // 色選択ダイアログ
  void _showColorPickerDialog(String dateKey) {
    final colors = [
      Colors.red,
      Colors.orange,
      Colors.yellow,
      Colors.green,
      Colors.blue,
      Colors.purple,
      Colors.pink,
      Colors.teal,
      Colors.indigo,
      Colors.brown,
    ];
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('日付の色を選択'),
        content: Wrap(
          spacing: 8,
          runSpacing: 8,
          children: colors.map((color) => GestureDetector(
            onTap: () async {
              // ✅ 変更前スナップショット（カレンダー日付色の設定）
              await _saveSnapshotBeforeChange('日付色変更_$dateKey');
              _dayColors[dateKey] = color;
              _dayColorsNotifier.value = Map<String, Color>.from(_dayColors);
              _saveDayColors();
              Navigator.pop(context);
              _showSnackBar('色を設定しました');
              // カレンダーを再描画
              // 部分更新はNotifierで反映済み
            },
            child: Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: color,
                shape: BoxShape.circle,
                border: Border.all(color: Colors.white, width: 2),
              ),
            ),
          )).toList(),
        ),
        actions: [
          TextButton(
            onPressed: () async {
              // ✅ 変更前スナップショット（カレンダー日付色のリセット）
              await _saveSnapshotBeforeChange('日付色リセット_$dateKey');
              _dayColors.remove(dateKey);
              _dayColorsNotifier.value = Map<String, Color>.from(_dayColors);
              _saveDayColors();
              Navigator.pop(context);
              _showSnackBar('色を削除しました');
              // カレンダーを再描画
              // 部分更新はNotifierで反映済み
            },
            child: const Text('色を削除'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('キャンセル'),
          ),
        ],
      ),
    );
  }
  Future<void> _updateMedicineInputsForSelectedDate() async {
    try {
      if (_selectedDay != null) {
        final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
        final dayData = _medicationData[dateStr];
        // 動的薬リストの復元
        _addedMedications = [];
        if (dayData != null) {
          for (final entry in dayData.entries) {
            if (entry.key.startsWith('added_medication_')) {
              _addedMedications.add({
                'name': entry.value.medicine,
                'type': '薬',
                'color': Colors.blue,
                'dosage': '',
                'notes': '',
                'isChecked': entry.value.checked,
              });
            }
          }
        }
        // メモの読み込み
        _loadMemoForSelectedDate();
      } else {
        _addedMedications = [];
        _memoController.clear();
      }
    } catch (e) {
    }
  }

  Future<void> _loadMemoForSelectedDate() async {
    try {
      if (_selectedDay != null) {
        final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
        final prefs = await SharedPreferences.getInstance();
        final savedMemo = prefs.getString('memo_$dateStr');
        if (savedMemo != null) {
          _memoController.text = savedMemo;
        } else {
          _memoController.clear();
        }
      }
    } catch (e) {
    }
  }


  // ✅ 改善版：服用メモ読み込み機能（多重バックアップ付き）
  Future<void> _loadMedicationMemos() async {
    try {
      debugPrint('📖 服用メモ読み込み開始...');
      
      // ✅ 1. Hiveボックスから読み込み
      if (Hive.isBoxOpen('medication_memos')) {
        final box = Hive.box<MedicationMemo>('medication_memos');
        final memos = box.values.toList();
        debugPrint('✅ Hiveから服用メモ読み込み成功: ${memos.length}件');
        
        setState(() {
          _medicationMemos = memos;
        });
        
        // ✅ バックアップとしてSharedPreferencesにも保存
        await _backupMemosToSharedPreferences();
        return;
      }
      
      // ✅ 2. Hiveが開いていない場合、SharedPreferencesから読み込み
      debugPrint('⚠️ Hiveボックスが開いていません。SharedPreferencesから読み込み...');
      final memos = await _loadMemosFromSharedPreferences();
      
      setState(() {
        _medicationMemos = memos;
      });
      
      debugPrint('✅ SharedPreferencesから服用メモ読み込み完了: ${memos.length}件');
    } catch (e, stackTrace) {
      debugPrint('❌ 服用メモ読み込みエラー: $e');
      debugPrint('スタックトレース: $stackTrace');
      
      // ✅ 3. エラー時は空のリストで初期化
      setState(() {
        _medicationMemos = [];
      });
    }
  }
  
  // ✅ SharedPreferencesからの服用メモ読み込み
  Future<List<MedicationMemo>> _loadMemosFromSharedPreferences() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final backupKeys = [
        'medication_memos_backup', 
        'medication_memos_backup2', 
        'medication_memos_backup3',
        'medication_memos_v2',
        'medication_memos'
      ];
      
      for (final key in backupKeys) {
        try {
          final backupJson = prefs.getString(key);
          if (backupJson != null && backupJson.isNotEmpty) {
            final List<dynamic> memosList = jsonDecode(backupJson);
            final memos = memosList
                .map((json) => MedicationMemo.fromJson(json as Map<String, dynamic>))
                .toList();
            debugPrint('✅ SharedPreferencesから復元: ${memos.length}件 ($key)');
            return memos;
      }
    } catch (e) {
          debugPrint('⚠️ キー $key の読み込みエラー: $e');
          continue;
        }
      }
      
      debugPrint('⚠️ 全てのバックアップが見つかりません');
      return [];
    } catch (e) {
      debugPrint('❌ SharedPreferences読み込みエラー: $e');
      return [];
    }
  }
  
  // ✅ SharedPreferencesへのバックアップ保存
  Future<void> _backupMemosToSharedPreferences() async {
    try {
      if (_medicationMemos.isEmpty) return;
      
      final prefs = await SharedPreferences.getInstance();
      final memosJson = _medicationMemos.map((memo) => memo.toJson()).toList();
      final jsonString = jsonEncode(memosJson);
      
      // ✅ 複数キーに保存（3重バックアップ）
      await Future.wait([
        prefs.setString('medication_memos_backup', jsonString),
        prefs.setString('medication_memos_backup2', jsonString),
        prefs.setString('medication_memos_backup3', jsonString),
        prefs.setString('medication_memos_v2', jsonString),
      ]);
      
      debugPrint('✅ 服用メモバックアップ保存完了: ${_medicationMemos.length}件');
    } catch (e) {
      debugPrint('❌ 服用メモバックアップ保存エラー: $e');
    }
  }
  
  // ✅ 改善版：服用メモ保存機能（多重バックアップ付き）
  Future<void> _saveMedicationMemoWithBackup(MedicationMemo memo) async {
    try {
      debugPrint('💾 服用メモ保存開始: ${memo.name}');
      
      // ✅ 1. Hiveボックスに保存
      if (Hive.isBoxOpen('medication_memos')) {
        final box = Hive.box<MedicationMemo>('medication_memos');
        await box.put(memo.id, memo);
        debugPrint('✅ Hiveに服用メモ保存完了');
      } else {
        debugPrint('⚠️ Hiveボックスが開いていません');
      }
      
      // ✅ 2. SharedPreferencesにもバックアップ保存
      await _backupMemosToSharedPreferences();
      
      debugPrint('✅ 服用メモ保存完了: ${memo.name}');
    } catch (e, stackTrace) {
      debugPrint('❌ 服用メモ保存エラー: $e');
      debugPrint('スタックトレース: $stackTrace');
      
      // ✅ エラー時もSharedPreferencesに保存を試行
      try {
        await _backupMemosToSharedPreferences();
        debugPrint('✅ フォールバック保存成功');
      } catch (backupError) {
        debugPrint('❌ フォールバック保存も失敗: $backupError');
      }
    }
  }
  
  // ✅ 改善版：服用メモ削除機能（多重バックアップ付き）
  Future<void> _deleteMedicationMemoWithBackup(String memoId) async {
    try {
      debugPrint('🗑️ 服用メモ削除開始: $memoId');
      
      // ✅ 1. Hiveボックスから削除
      if (Hive.isBoxOpen('medication_memos')) {
        final box = Hive.box<MedicationMemo>('medication_memos');
        await box.delete(memoId);
        debugPrint('✅ Hiveから服用メモ削除完了');
      } else {
        debugPrint('⚠️ Hiveボックスが開いていません');
      }
      
      // ✅ 2. SharedPreferencesにもバックアップ保存
      await _backupMemosToSharedPreferences();
      
      debugPrint('✅ 服用メモ削除完了: $memoId');
    } catch (e, stackTrace) {
      debugPrint('❌ 服用メモ削除エラー: $e');
      debugPrint('スタックトレース: $stackTrace');
      
      // ✅ エラー時もSharedPreferencesに保存を試行
      try {
        await _backupMemosToSharedPreferences();
        debugPrint('✅ フォールバック保存成功');
      } catch (backupError) {
        debugPrint('❌ フォールバック保存も失敗: $backupError');
      }
    }
  }
  
  // ✅ 新規追加：リトライ機能付きの服用メモ読み込み
  Future<void> _loadMedicationMemosWithRetry({int maxRetries = 3}) async {
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        debugPrint('🔄 服用メモ読み込み試行 $attempt/$maxRetries');
        
        // Hiveボックスが開いているか確認
        if (!Hive.isBoxOpen('medication_memos')) {
          debugPrint('⚠️ medication_memosボックスが開いていません。再度開きます...');
          await Hive.openBox<MedicationMemo>('medication_memos');
        }
        
        // データ読み込み
        final memos = await AppPreferences.loadMedicationMemos();
        
        if (memos.isNotEmpty || attempt == maxRetries) {
          setState(() {
            _medicationMemos = memos;
          });
          debugPrint('✅ 服用メモ読み込み成功: ${memos.length}件（試行$attempt回目）');
          return;
        }
        
        // データが空の場合、次の試行前に少し待つ
        if (attempt < maxRetries) {
          debugPrint('⚠️ データが空です。${attempt + 1}回目の試行を実行します...');
          await Future.delayed(Duration(milliseconds: 500 * attempt));
        }
    } catch (e) {
        debugPrint('❌ 服用メモ読み込みエラー（試行$attempt回目）: $e');
        
        if (attempt == maxRetries) {
          debugPrint('❌ 最大試行回数に達しました。バックアップから復元を試みます...');
          // バックアップから復元を試みる
          await _restoreMedicationMemosFromBackup();
        } else {
          await Future.delayed(Duration(milliseconds: 500 * attempt));
        }
      }
    }
  }
  
  // ✅ 新規追加：バックアップからの復元
  Future<void> _restoreMedicationMemosFromBackup() async {
    try {
      debugPrint('🔄 バックアップから服用メモを復元中...');
      final prefs = await SharedPreferences.getInstance();
      
      // 複数のバックアップキーを試す
      final backupKeys = [
        'medication_memos_backup',
        'medication_memos_backup2',
        'medication_memos_backup3',
      ];
      
      for (final key in backupKeys) {
        final backupJson = prefs.getString(key);
        if (backupJson != null && backupJson.isNotEmpty) {
          try {
            final List<dynamic> memosList = jsonDecode(backupJson);
            final memos = memosList
                .map((json) => MedicationMemo.fromJson(json as Map<String, dynamic>))
                .toList();
            
            if (memos.isNotEmpty) {
              // Hiveボックスに復元
              final box = Hive.box<MedicationMemo>('medication_memos');
              await box.clear();
              for (final memo in memos) {
                await box.put(memo.id, memo);
              }
      
      setState(() {
        _medicationMemos = memos;
      });
      
              debugPrint('✅ バックアップから復元成功: ${memos.length}件 ($key)');
      
              // 成功メッセージを表示
      if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('バックアップから${memos.length}件のメモを復元しました'),
                    backgroundColor: Colors.green,
                    duration: const Duration(seconds: 3),
                  ),
                );
              }
              return;
      }
    } catch (e) {
            debugPrint('⚠️ バックアップ解析エラー ($key): $e');
            continue;
          }
        }
      }
      
      debugPrint('⚠️ 全てのバックアップが見つかりません');
    } catch (e) {
      debugPrint('❌ バックアップ復元エラー: $e');
    }
  }

  void _showSnackBar(String message) async {
    if (!mounted) return;
    try {
      final fontSize = await MedicationAlarmApp.getFontSize();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              message,
              style: TextStyle(fontSize: fontSize),
              overflow: TextOverflow.ellipsis,
              maxLines: 2,
            ),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          ),
        );
      }
    } catch (e) {
    }
  }
  // 完全に作り直されたカレンダーイベント取得
  List<Widget> _getEventsForDay(DateTime day) {
    try {
      final dateStr = DateFormat('yyyy-MM-dd').format(day);
      final weekday = day.weekday % 7;
      
      // 完全に作り直されたチェック
      bool hasMedications = false;
      bool allTaken = true;
      int takenCount = 0;
      int totalCount = 0;
      
      // 動的薬リストのチェック
      if (_addedMedications.isNotEmpty) {
        hasMedications = true;
        totalCount += _addedMedications.length;
        for (final medication in _addedMedications) {
          if (medication['isChecked'] == true) {
            takenCount++;
          } else {
            allTaken = false;
          }
        }
      }
      
      // 服用メモのチェック
      for (final memo in _medicationMemos) {
        if (memo.selectedWeekdays.isNotEmpty && memo.selectedWeekdays.contains(weekday)) {
          hasMedications = true;
          totalCount++;
          if (_medicationMemoStatus[memo.id] == true) {
            takenCount++;
          } else {
            allTaken = false;
          }
        }
      }
      
      // 完全に作り直されたマーク表示（すべてのマークを削除）
      // 赤丸を含むすべてのマークを削除
      return [];
    } catch (e) {
      return [];
    }
  }
  // 服用記録の件数を取得するヘルパーメソッド
  int _getMedicationRecordCount() {
    return _addedMedications.length + _getMedicationsForSelectedDay().length;
  }




  Widget _buildCalendarTab() {
    return LayoutBuilder(
      builder: (context, constraints) {
        final screenWidth = MediaQuery.of(context).size.width;
        final screenHeight = MediaQuery.of(context).size.height;
        final isSmallScreen = screenHeight < 600;
        final isNarrowScreen = screenWidth < 360;
        
        return Column(
            children: [
            // ✅ スワイプ可能なカレンダーエリア
              Expanded(
                flex: 1,
              child: NotificationListener<ScrollNotification>(
                onNotification: (notification) {
                  // スクロール通知を処理
                  return true;
                  },
                  child: SingleChildScrollView(
          controller: _calendarScrollController,
                  physics: const ClampingScrollPhysics(),
                  child: Column(
                    children: [
                      Padding(
          padding: EdgeInsets.symmetric(
                        horizontal: isNarrowScreen ? 8 : screenWidth * 0.05,
                        vertical: isSmallScreen ? 4 : 8,
          ),
          child: Column(
            children: [
                          // メモフィールド
              if (_selectedDay != null)
                Container(
                              margin: const EdgeInsets.only(bottom: 16),
                  padding: EdgeInsets.fromLTRB(
                                isSmallScreen ? 8 : (isNarrowScreen ? 12 : 16),
                                0,
                                isSmallScreen ? 8 : (isNarrowScreen ? 12 : 16),
                                isSmallScreen ? 8 : (isNarrowScreen ? 12 : 16),
                  ),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: Colors.grey.withOpacity(0.3)),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.grey.withOpacity(0.1),
                        spreadRadius: 1,
                        blurRadius: 4,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Text(
                            '今日のメモ',
                            style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        ],
                      ),
                      _buildMemoField(),
                    ],
                  ),
                ),
                        
                            // ✅ カレンダー本体（スワイプ検出を改善）
                            GestureDetector(
                              // ✅ 修正：スワイプを確実に検出
                              behavior: HitTestBehavior.translucent,
                              onVerticalDragStart: (_) {
                                // ドラッグ開始を検出
                                debugPrint('カレンダー: ドラッグ開始');
                              },
                              onVerticalDragUpdate: (details) {
                                // スワイプの方向と距離を検出
                                final delta = details.delta.dy;
                                
                                if (delta < -3) { // 上スワイプ（感度を調整）
                                  // 下にスクロール（服用記録を表示）
                                  if (_calendarScrollController.hasClients) {
                                    final maxScroll = _calendarScrollController.position.maxScrollExtent;
                                    final currentScroll = _calendarScrollController.offset;
                                    final targetScroll = (currentScroll + 30).clamp(0.0, maxScroll);
                                    
                                    _calendarScrollController.animateTo(
                                      targetScroll,
                                      duration: const Duration(milliseconds: 100),
                                      curve: Curves.easeOut,
                                    );
                                  }
                                } else if (delta > 3) { // 下スワイプ（感度を調整）
                                  // 上にスクロール（カレンダーを表示）
                                  if (_calendarScrollController.hasClients) {
                                    final currentScroll = _calendarScrollController.offset;
                                    final targetScroll = (currentScroll - 30).clamp(0.0, double.infinity);
                                    
                                    _calendarScrollController.animateTo(
                                      targetScroll,
                                      duration: const Duration(milliseconds: 100),
                                      curve: Curves.easeOut,
                                    );
                                  }
                                }
                              },
                              onVerticalDragEnd: (details) {
                                // ドラッグ終了時の処理
                                final velocity = details.primaryVelocity ?? 0;
                                
                                if (!_calendarScrollController.hasClients) return;
                                
                                if (velocity < -300) { // 上スワイプ（速い）
                                  // 服用記録まで一気にスクロール
                                  _calendarScrollController.animateTo(
                                    _calendarScrollController.position.maxScrollExtent,
                                    duration: const Duration(milliseconds: 300),
                                    curve: Curves.easeOut,
                                  );
                                } else if (velocity > 300) { // 下スワイプ（速い）
                                  // カレンダーまで一気にスクロール
                                  _calendarScrollController.animateTo(
                                    0,
                                    duration: const Duration(milliseconds: 300),
                                    curve: Curves.easeOut,
                                  );
                                }
                              },
                              child: SizedBox(
                            height: 350,
                child: Container(
                decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(16),
                  gradient: const LinearGradient(
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                    colors: [
                      Color(0xFF667eea),
                      Color(0xFF764ba2),
                    ],
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: const Color(0xFF667eea).withOpacity(0.3),
                      spreadRadius: 1,
                      blurRadius: 10,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
                              child: Stack(
                                children: [
                                      // カレンダー本体
                                      ClipRRect(
                  borderRadius: BorderRadius.circular(16),
                    child: TableCalendar<dynamic>(
                      firstDay: DateTime.utc(2020, 1, 1),
                      lastDay: DateTime.utc(2030, 12, 31),
                      focusedDay: _focusedDay,
                      calendarFormat: CalendarFormat.month,
                      eventLoader: _getEventsForDay,
                      startingDayOfWeek: StartingDayOfWeek.monday,
                      locale: 'ja_JP', // 日本語ロケール（initializeDateFormattingで初期化済み）
                                          // ✅ カレンダー独自のジェスチャーを無効化
                                          availableGestures: AvailableGestures.none,
                      calendarBuilders: CalendarBuilders(
                        defaultBuilder: (context, day, focusedDay) {
                                        return _buildCalendarDay(day);
                                      },
                                      selectedBuilder: (context, day, focusedDay) {
                                        return _buildCalendarDay(day, isSelected: true);
                                      },
                                      todayBuilder: (context, day, focusedDay) {
                                        return _buildCalendarDay(day, isToday: true);
                                      },
                                    ),
                                    headerStyle: HeaderStyle(
                        formatButtonVisible: false,
                        titleCentered: true,
                                      titleTextStyle: const TextStyle(
                                        fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                                      leftChevronIcon: const Icon(Icons.chevron_left, color: Colors.white, size: 20),
                                      rightChevronIcon: const Icon(Icons.chevron_right, color: Colors.white, size: 20),
                                      decoration: const BoxDecoration(
                          gradient: LinearGradient(
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                            colors: [
                              Color(0xFF667eea),
                              Color(0xFF764ba2),
                            ],
                          ),
                        ),
                      ),
                      daysOfWeekStyle: const DaysOfWeekStyle(
                        weekdayStyle: TextStyle(
                          fontWeight: FontWeight.bold,
                                        fontSize: 12,
                          color: Colors.white,
                        ),
                        weekendStyle: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                                        fontSize: 12,
                        ),
                      ),
                      calendarStyle: _buildCalendarStyle(),
                      onDaySelected: _onDaySelected,
                      selectedDayPredicate: (day) {
                        return _selectedDates.contains(_normalizeDate(day));
                      },
                      onPageChanged: (focusedDay) {
                        _focusedDay = focusedDay;
                      },
                  ),
                ),
                                
                                      // 左上：左移動ボタン
                                Positioned(
                                  top: 12,
                                  left: 12,
                                  child: Material(
                                    color: Colors.transparent,
                                    child: InkWell(
                                      onTap: () {
                                        _focusedDay = DateTime(_focusedDay.year, _focusedDay.month - 1);
                                        setState(() {});
                                      },
                                      borderRadius: BorderRadius.circular(20),
                                      child: Container(
                                        padding: const EdgeInsets.all(8),
                                        decoration: BoxDecoration(
                                          color: Colors.white.withOpacity(0.9),
                                          borderRadius: BorderRadius.circular(20),
                                          boxShadow: [
                                            BoxShadow(
                                              color: Colors.black.withOpacity(0.2),
                                              blurRadius: 4,
                                              offset: const Offset(0, 2),
                                            ),
                                          ],
                                        ),
                                        child: const Icon(
                                          Icons.arrow_back,
                                          color: Colors.blue,
                                          size: 20,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                                
                                      // 右上：右移動ボタン
                                Positioned(
                                  top: 12,
                                  right: 12,
                                  child: Material(
                                    color: Colors.transparent,
                                    child: InkWell(
                                      onTap: () {
                                        _focusedDay = DateTime(_focusedDay.year, _focusedDay.month + 1);
                                        setState(() {});
                                      },
                                      borderRadius: BorderRadius.circular(20),
                                      child: Container(
                                        padding: const EdgeInsets.all(8),
                                        decoration: BoxDecoration(
                                          color: Colors.white.withOpacity(0.9),
                                          borderRadius: BorderRadius.circular(20),
                                          boxShadow: [
                                            BoxShadow(
                                              color: Colors.black.withOpacity(0.2),
                                              blurRadius: 4,
                                              offset: const Offset(0, 2),
                                            ),
                                          ],
                                        ),
                                        child: const Icon(
                                          Icons.arrow_forward,
                                          color: Colors.blue,
                                          size: 20,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                                
                                      // 左矢印アイコンの右側：色変更アイコン
                                Positioned(
                                  top: 12,
                                        left: 60,
                                  child: Material(
                                    color: Colors.transparent,
                                    child: InkWell(
                                      onTap: _changeDayColor,
                                      borderRadius: BorderRadius.circular(15),
                                      child: Container(
                                        padding: const EdgeInsets.all(6),
                                        decoration: BoxDecoration(
                                          color: Colors.white.withOpacity(0.9),
                                          borderRadius: BorderRadius.circular(15),
                                          boxShadow: [
                                            BoxShadow(
                                              color: Colors.black.withOpacity(0.2),
                                              blurRadius: 3,
                                              offset: const Offset(0, 1),
                                            ),
                                          ],
                                        ),
                                        child: const Icon(
                                          Icons.palette,
                                          color: Colors.purple,
                                          size: 16,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                                  ),
                            ),
                          ),
                        ),
                        
                          const SizedBox(height: 12),
                          
                          // 今日の服用状況表示
              if (_selectedDay != null)
                _buildMedicationStats(),
                          
              const SizedBox(height: 8),
                          
                          // 服用記録セクション
              if (_selectedDay != null)
                _buildMedicationRecords(),
                          
              const SizedBox(height: 20),
                        ],
                      ),
                    ),
                    ],
                  ),
                ),
              ),
          ),
          ],
        );
      },
    );
  }

  // ✅ ③④ カレンダーの日付セル（曜日マーク・チェックマーク表示）
  Widget _buildCalendarDay(DateTime day, {bool isSelected = false, bool isToday = false}) {
    final dateStr = DateFormat('yyyy-MM-dd').format(day);
    final weekday = day.weekday % 7;
    
    // ③服用メモで設定された曜日かチェック
    final hasScheduledMemo = _medicationMemos.any((memo) => 
      memo.selectedWeekdays.isNotEmpty && memo.selectedWeekdays.contains(weekday)
    );
    
    // ④服用記録が100%かチェック
    final stats = _calculateDayMedicationStats(day);
    final total = stats['total'] ?? 0;
    final taken = stats['taken'] ?? 0;
    final isComplete = total > 0 && taken == total;
    
    // カスタム色取得
    final customColor = _dayColors[dateStr];
    
    return Container(
      margin: const EdgeInsets.all(2),
      decoration: BoxDecoration(
        color: customColor ?? 
          (isSelected 
            ? const Color(0xFFff6b6b)
            : isToday 
              ? const Color(0xFF4ecdc4)
              : Colors.white.withOpacity(0.1)),
        borderRadius: BorderRadius.circular(8),
        border: hasScheduledMemo 
          ? Border.all(color: Colors.amber, width: 2)
          : null,
        boxShadow: isSelected || isToday
          ? [
              BoxShadow(
                color: (customColor ?? (isSelected ? const Color(0xFFff6b6b) : const Color(0xFF4ecdc4))).withOpacity(0.3),
                spreadRadius: 1,
                blurRadius: 8,
                offset: const Offset(0, 2),
              ),
            ]
          : null,
      ),
      child: Stack(
        children: [
          // 日付
          Center(
            child: Text(
              '${day.day}',
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
                fontSize: 14,
              ),
            ),
          ),
          
          // ③曜日マーク（左上）
          if (hasScheduledMemo)
            Positioned(
              top: 2,
              left: 2,
              child: Container(
                width: 8,
                height: 8,
                decoration: BoxDecoration(
                  color: Colors.amber,
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.amber.withOpacity(0.5),
                      blurRadius: 2,
                    ),
                  ],
                ),
              ),
            ),
          
          // ④完了チェックマーク（右下）
          if (isComplete)
            Positioned(
              bottom: 2,
              right: 2,
              child: Container(
                padding: const EdgeInsets.all(2),
                decoration: BoxDecoration(
                  color: Colors.green,
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.green.withOpacity(0.5),
                      blurRadius: 2,
                    ),
                  ],
                ),
                child: const Icon(
                  Icons.check,
                  color: Colors.white,
                  size: 10,
                ),
              ),
            ),
        ],
      ),
    );
  }

  // 日別の服用統計を計算
  Map<String, int> _calculateDayMedicationStats(DateTime day) {
    final dateStr = DateFormat('yyyy-MM-dd').format(day);
    final weekday = day.weekday % 7;
    
    int totalMedications = 0;
    int takenMedications = 0;
    
    // 動的薬リストの統計
    if (_medicationData.containsKey(dateStr)) {
      final dayData = _medicationData[dateStr]!;
      totalMedications += dayData.length;
      takenMedications += dayData.values.where((info) => info.checked).length;
    }
    
    // 服用メモの統計
    for (final memo in _medicationMemos) {
      if (memo.selectedWeekdays.isNotEmpty && memo.selectedWeekdays.contains(weekday)) {
        totalMedications += memo.dosageFrequency;
        final checkedCount = _getMedicationMemoCheckedCountForDate(memo.id, dateStr);
        takenMedications += checkedCount;
      }
    }
    
    return {'total': totalMedications, 'taken': takenMedications};
  }

  // 指定日のメモの服用済み回数を取得
  int _getMedicationMemoCheckedCountForDate(String memoId, String dateStr) {
    final doseStatus = _weekdayMedicationDoseStatus[dateStr]?[memoId];
    if (doseStatus == null) return 0;
    return doseStatus.values.where((isChecked) => isChecked).length;
  }

  // 日付の色を変更するメソッド
  void _changeDayColor() {
    if (_selectedDay == null) return;
    
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    final colors = [
      {'color': const Color(0xFFff6b6b), 'name': '赤'},
      {'color': const Color(0xFF4ecdc4), 'name': '青緑'},
      {'color': const Color(0xFF45b7d1), 'name': '青'},
      {'color': const Color(0xFFf9ca24), 'name': '黄色'},
      {'color': const Color(0xFFf0932b), 'name': 'オレンジ'},
      {'color': const Color(0xFFeb4d4b), 'name': 'ピンク'},
      {'color': const Color(0xFF6c5ce7), 'name': '紫'},
      {'color': const Color(0xFFa29bfe), 'name': '薄紫'},
      {'color': const Color(0xFF00d2d3), 'name': 'ターコイズ'},
      {'color': const Color(0xFF1e3799), 'name': '濃紺'},
      {'color': const Color(0xFFe55039), 'name': 'トマト'},
      {'color': const Color(0xFF2ecc71), 'name': 'エメラルド'},
    ];
    
    // 色選択ダイアログを表示
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text(
            'カレンダーの色を選択',
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
          content: SizedBox(
            width: double.maxFinite,
            height: 300, // 高さを制限
            child: GridView.builder(
              shrinkWrap: true,
              physics: const BouncingScrollPhysics(), // スクロール可能
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 3,
                crossAxisSpacing: 12,
                mainAxisSpacing: 13.7,
                childAspectRatio: 1,
              ),
              itemCount: colors.length + 1, // +1 for "色をリセット"
              itemBuilder: (context, index) {
                if (index == colors.length) {
                  // 色をリセットボタン（デフォルト色に戻す）
                  return GestureDetector(
                    onTap: () async {
                      // ✅ 追加：変更前スナップショット
                      await _saveSnapshotBeforeChange('カレンダー色リセット_$dateStr');
                      setState(() {
                        // デフォルト色（何も指定していない最初の色）に戻す
                        _dayColors.remove(dateStr);
                        _dayColorsNotifier.value = Map<String, Color>.from(_dayColors);
                      });
                      await _saveDayColors(); // データ保存
                      Navigator.of(context).pop();
                    },
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(color: Colors.grey, width: 2),
                      ),
                      child: const Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.clear, color: Colors.grey, size: 32),
                          SizedBox(height: 4),
                          Text(
                            'リセット',
                            style: TextStyle(
                              fontSize: 10,
                              color: Colors.grey,
                              fontWeight: FontWeight.bold,
                            ),
                            textAlign: TextAlign.center,
                          ),
                        ],
                      ),
                    ),
                  );
                }
                
                final colorData = colors[index];
                final color = colorData['color'] as Color;
                final name = colorData['name'] as String;
                final isSelected = _dayColors[dateStr] == color;
                
                return GestureDetector(
                  onTap: () async {
                    // ✅ 追加：変更前スナップショット
                    await _saveSnapshotBeforeChange('カレンダー色変更_${dateStr}_$name');
                    setState(() {
                      _dayColors[dateStr] = color;
                      _dayColorsNotifier.value = Map<String, Color>.from(_dayColors);
                    });
                    await _saveDayColors(); // データ保存
                    Navigator.of(context).pop();
                  },
                  child: Container(
                    decoration: BoxDecoration(
                      color: color,
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(
                        color: isSelected ? Colors.white : Colors.transparent,
                        width: 3,
                      ),
                      boxShadow: [
                        BoxShadow(
                          color: color.withOpacity(0.5),
                          spreadRadius: 1,
                          blurRadius: 4,
                          offset: const Offset(0, 2),
                        ),
                      ],
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        if (isSelected)
                          const Icon(
                            Icons.check_circle,
                            color: Colors.white,
                            size: 32,
                          )
                        else
                          const SizedBox(height: 32),
                        const SizedBox(height: 4),
                        Text(
                          name,
                          style: const TextStyle(
                            fontSize: 10,
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                            shadows: [
                              Shadow(
                                offset: Offset(1, 1),
                                blurRadius: 2,
                                color: Colors.black45,
                              ),
                            ],
                          ),
                          textAlign: TextAlign.center,
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('キャンセル'),
            ),
          ],
        );
      },
    );
  }

  Widget _buildMedicationRecords() {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.15),
            spreadRadius: 2,
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min, // 最小サイズに制限
        children: [
          // ヘッダー
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20), // パディング削減
            decoration: BoxDecoration(
              gradient: const LinearGradient(
                colors: [Color(0xFF2196F3), Color(0xFF1976D2)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(20),
                topRight: Radius.circular(20),
              ),
            ),
            child: Column(
              children: [
                Text(
                  '${DateFormat('yyyy年M月d日', 'ja_JP').format(_selectedDay!)}の服用記録',
                  style: const TextStyle(
                    fontSize: 18, // フォントサイズ削減
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 4), // 間隔削減
                Text(
                  '今日の服用状況を確認しましょう',
                  style: TextStyle(
                    fontSize: 12, // フォントサイズ削減
                    color: Colors.white.withOpacity(0.9),
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
          // 完全に作り直された服用記録リスト
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                  // メモ選択時は選択されたメモのみ表示
                  if (_isMemoSelected && _selectedMemo != null) ...[
                    // 戻るボタン
                    Container(
                      margin: const EdgeInsets.only(bottom: 16),
                      child: Row(
                    children: [
                      GestureDetector(
                        onTap: () {
                          setState(() {
                            _isMemoSelected = false;
                            _selectedMemo = null;
                          });
                        },
                            child: Container(
                              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                              decoration: BoxDecoration(
                                color: Colors.blue.withOpacity(0.1),
                                borderRadius: BorderRadius.circular(20),
                                border: Border.all(color: Colors.blue, width: 1),
                              ),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                    children: [
                                  Icon(Icons.arrow_back, color: Colors.blue, size: 16),
                                  const SizedBox(width: 8),
                            Text(
                                    '戻る',
                              style: TextStyle(
                                      color: Colors.blue,
                                fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                              ),
                        ),
                      ),
                    ],
                  ),
                    ),
                    _buildWeekdayMedicationRecord(_selectedMemo!)
                  ] else ...[
                    // カレンダー下の位置マーカー
                    SizedBox(
                      key: _calendarBottomKey,
                      height: 1, // 見えないマーカー
                    ),
                    // ✅ 修正：服用記録リスト（ページめくり方式・SizedBox）
                    _getMedicationListLength() == 0
                        ? SizedBox(
                            height: MediaQuery.of(context).size.height * 0.4, // MediaQuery使用
                            child: _buildNoMedicationMessage(),
                          )
                        : SizedBox(
                            height: 400, // 固定高さを設定
                            child: PageView.builder(
                              controller: _medicationPageController,
                              onPageChanged: (index) {
                                setState(() {
                                  _currentMedicationPage = index;
                                });
                              },
                              itemCount: _getMedicationListLength(),
                              itemBuilder: (context, index) {
                                return _buildMedicationItem(index);
                              },
                            ),
                          ),
                    // 服用数の表示UI（メモ0のときは表示しない）
                    if (_getMedicationListLength() > 0 && _getMedicationListLength() != 1)
                      Container(
                        margin: const EdgeInsets.symmetric(vertical: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                        decoration: BoxDecoration(
                          color: Colors.blue.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(20),
                          border: Border.all(color: Colors.blue, width: 1),
                        ),
                        child: Text(
                          '${_currentMedicationPage + 1}/${_getMedicationListLength()} 服用の数',
                          style: const TextStyle(
                            color: Colors.blue,
                            fontWeight: FontWeight.bold,
                            fontSize: 14,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    // ページめくりボタン
                    if (_getMedicationListLength() > 1)
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        child: Row(
                          children: [
                            Expanded(
                              child: ElevatedButton(
                                onPressed: _currentMedicationPage > 0 ? () {
                                  _medicationPageController.previousPage(
                                    duration: const Duration(milliseconds: 300),
                                    curve: Curves.easeInOut,
                                  );
                                } : null,
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: _currentMedicationPage > 0 ? Colors.blue : Colors.grey,
                                  foregroundColor: Colors.white,
                                  padding: const EdgeInsets.symmetric(vertical: 12),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                ),
                                child: const Text(
                                  '前の\n服用内容',
                                  textAlign: TextAlign.center,
                                  style: TextStyle(fontSize: 12),
                                ),
                              ),
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: ElevatedButton(
                                onPressed: _currentMedicationPage < _getMedicationListLength() - 1 ? () {
                                  _medicationPageController.nextPage(
                                    duration: const Duration(milliseconds: 300),
                                    curve: Curves.easeInOut,
                                  );
                                } : null,
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: _currentMedicationPage < _getMedicationListLength() - 1 ? Colors.blue : Colors.grey,
                                  foregroundColor: Colors.white,
                                  padding: const EdgeInsets.symmetric(vertical: 12),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                ),
                                child: const Text(
                                  '次の\n服用内容',
                                  textAlign: TextAlign.center,
                                  style: TextStyle(fontSize: 12),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                  ],
                ],
            ),
          ),
          // フッター統計（削除）
        ],
      ),
    );
  }

  // 安全な最大高さを計算する関数

  // 服用記録リストの長さを取得
  int _getMedicationListLength() {
    final addedCount = _addedMedications.length;
    final memoCount = _getMedicationsForSelectedDay().length;
    final hasNoData = addedCount == 0 && memoCount == 0;
    return addedCount + memoCount + (hasNoData ? 1 : 0);
  }

  // 服用記録アイテムを構築
  Widget _buildMedicationItem(int index) {
    final addedCount = _addedMedications.length;
    final memoCount = _getMedicationsForSelectedDay().length;
    
    if (index < addedCount) {
      // 追加された薬
      return _buildAddedMedicationRecord(_addedMedications[index]);
    } else if (index < addedCount + memoCount) {
      // 服用メモ
      final memoIndex = index - addedCount;
      return _buildMedicationMemoCheckbox(_getMedicationsForSelectedDay()[memoIndex]);
    } else {
      // データなしメッセージ
      return _buildNoMedicationMessage();
    }
  }

  // 服用メモが未追加の場合のメッセージ表示
  Widget _buildNoMedicationMessage() {
    return Container(
      height: 450, // 高さを450pxに設定
      margin: const EdgeInsets.symmetric(vertical: 20),
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.05),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: Colors.blue.withOpacity(0.3),
          width: 1,
        ),
      ),
      child: Column(
        children: [
          Icon(
            Icons.info_outline,
            color: Colors.blue,
            size: 48,
          ),
          const SizedBox(height: 16),
          Text(
            '服用メモから服用スケジュール\n(毎日、曜日)を選択してください',
            style: TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.bold,
              color: Theme.of(context).brightness == Brightness.dark 
                  ? Colors.white 
                  : Colors.black87,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            '服用メモタブで薬品やサプリメントを追加してから、\nカレンダーページで服用スケジュールを管理できます。',
            style: TextStyle(
              fontSize: 14,
              color: Theme.of(context).brightness == Brightness.dark 
                  ? Colors.white 
                  : Colors.black87,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          ElevatedButton.icon(
            onPressed: () {
              // 服用メモタブに切り替え
              _tabController.animateTo(1);
            },
            icon: const Icon(Icons.add),
            label: const Text('服用メモを追加'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blue,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
        ],
      ),
    );
  }

  // 服用メモのチェックボックス（カレンダーページ用・拡大版）
  Widget _buildMedicationMemoCheckbox(MedicationMemo memo) {
    final isSelected = _isMemoSelected && _selectedMemo?.id == memo.id;
    // 服用回数に応じたチェック状況を取得
    final checkedCount = _getMedicationMemoCheckedCountForSelectedDay(memo.id);
    final totalCount = memo.dosageFrequency;
    
    return Container(
        margin: const EdgeInsets.only(bottom: 12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected 
                ? Colors.blue 
                : checkedCount == totalCount 
                    ? Colors.green 
                    : Colors.grey.withOpacity(0.3),
            width: isSelected ? 2 : checkedCount == totalCount ? 1.5 : 1,
          ),
          color: isSelected 
              ? Colors.blue.withOpacity(0.1)
              : checkedCount == totalCount 
                  ? Colors.green.withOpacity(0.05) 
                  : Colors.white,
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.1),
              spreadRadius: 1,
              blurRadius: 4,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 上部：アイコン、薬名、服用回数情報
              Row(
                children: [
                  // 大きなアイコン
                  CircleAvatar(
                    backgroundColor: memo.color,
                    radius: 20,
                    child: Icon(
                      memo.type == 'サプリメント' ? Icons.eco : Icons.medication,
                      color: Colors.white,
                      size: 20,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // 薬名と種類
                        Text(
                          memo.name,
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: checkedCount == totalCount ? Colors.green : Colors.black87,
                          ),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 4),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: checkedCount == totalCount ? Colors.green.withOpacity(0.2) : memo.color.withOpacity(0.2),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Text(
                            memo.type,
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.w500,
                              color: checkedCount == totalCount ? Colors.green : memo.color,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              // 服用回数に応じたチェックボックス
              const SizedBox(height: 12),
              Row(
                children: List.generate(totalCount, (index) {
                  final isChecked = _getMedicationMemoDoseStatusForSelectedDay(memo.id, index);
                  return Expanded(
                    child: Semantics(
                      label: '${memo.name}の服用記録 ${index + 1}回目',
                      hint: 'タップして服用状態を切り替え',
                    child: GestureDetector(
                      onTap: () async {
                        if (_selectedDay != null) {
                          // ✅ 追加：変更前スナップショット
                          await _saveSnapshotBeforeChange('服用回数チェック_${memo.name}_${index + 1}回目_${DateFormat('yyyy-MM-dd').format(_selectedDay!)}');
                          final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
                          setState(() {
                            // 日付別の服用メモ状態を更新
                            _weekdayMedicationStatus.putIfAbsent(dateStr, () => {});
                            _weekdayMedicationDoseStatus.putIfAbsent(dateStr, () => {});
                            _weekdayMedicationDoseStatus[dateStr]!.putIfAbsent(memo.id, () => {});
                            _weekdayMedicationDoseStatus[dateStr]![memo.id]![index] = !isChecked;
                            
                            // 全体の服用状況を更新（全回数完了時に服用済み）
                            final checkedCount = _getMedicationMemoCheckedCountForSelectedDay(memo.id);
                            final totalCount = memo.dosageFrequency;
                            _weekdayMedicationStatus[dateStr]![memo.id] = checkedCount == totalCount;
                            _medicationMemoStatus[memo.id] = checkedCount == totalCount;
                          });
                          // データ保存
                          await _saveAllData();
                          // 統計を再計算
                          await _calculateAdherenceStats();
                        }
                      },
                      child: Container(
                        margin: const EdgeInsets.symmetric(horizontal: 2),
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        decoration: BoxDecoration(
                          color: isChecked ? Colors.green : Colors.grey.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: isChecked ? Colors.green : Colors.grey.withOpacity(0.3),
                            width: 1,
                          ),
                        ),
                        child: Column(
                          children: [
                            Icon(
                              isChecked ? Icons.check_circle : Icons.radio_button_unchecked,
                              color: isChecked ? Colors.white : Colors.grey,
                              size: 20,
                            ),
                            const SizedBox(height: 4),
                            Text(
                              '${index + 1}回目',
                              style: TextStyle(
                                fontSize: 10,
                                color: isChecked ? Colors.white : Colors.grey[600],
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                          ],
                        ),
                        ),
                      ),
                    ),
                  );
                }),
              ),
              // 服用回数情報
              const SizedBox(height: 12),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                decoration: BoxDecoration(
                  color: Colors.blue.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    const Icon(Icons.repeat, size: 16, color: Colors.blue),
                    const SizedBox(width: 8),
                    Text(
                      '服用回数: ${memo.dosageFrequency}回 (${checkedCount}/${totalCount})',
                      style: TextStyle(
                        fontSize: 14,
                        color: checkedCount == totalCount ? Colors.green : Colors.blue[700],
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    if (memo.dosageFrequency >= 6) ...[
                      const SizedBox(width: 8),
                      GestureDetector(
                        onTap: () {
                          _showWarningDialog(context);
                        },
                        child: const Icon(Icons.warning, size: 16, color: Colors.orange),
                      ),
                    ],
                  ],
                ),
              ),
              // 用量情報
              if (memo.dosage.isNotEmpty) ...[
                const SizedBox(height: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  decoration: BoxDecoration(
                    color: Colors.grey.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.straighten, size: 16, color: Colors.grey),
                      const SizedBox(width: 8),
                      Text(
                        '用量: ${memo.dosage}',
                        style: TextStyle(
                          fontSize: 14,
                          color: checkedCount == totalCount ? Colors.green : Colors.grey[700],
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
              // メモ情報（タップ可能）
              if (memo.notes.isNotEmpty) ...[
                const SizedBox(height: 12),
                GestureDetector(
                  onTap: () {
                    _showMemoDetailDialog(context, memo.name, memo.notes);
                  },
                  child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.05),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.blue.withOpacity(0.2)),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          const Icon(Icons.note, size: 16, color: Colors.blue),
                          const SizedBox(width: 8),
                          const Text(
                            'メモ',
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                              color: Colors.blue,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 6),
                      Text(
                        memo.notes,
                        style: const TextStyle(
                          fontSize: 14,
                          color: Colors.black87,
                          height: 1.4,
                        ),
                          maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                        const SizedBox(height: 4),
                        Text(
                          'タップしてメモを表示',
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.blue.withOpacity(0.7),
                            fontStyle: FontStyle.italic,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
    );
  }

  // メモ詳細ダイアログを表示
  void _showMemoDetailDialog(BuildContext context, String medicationName, String memo) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        child: Container(
          width: MediaQuery.of(context).size.width * 0.9,
          height: MediaQuery.of(context).size.height * 0.7,
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // ヘッダー
              Row(
                children: [
                  const Icon(Icons.note, size: 24, color: Colors.blue),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      '$medicationName のメモ',
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Colors.blue,
                      ),
                    ),
                  ),
                  IconButton(
                    onPressed: () => Navigator.of(context).pop(),
                    icon: const Icon(Icons.close, color: Colors.grey),
                  ),
                ],
              ),
              const Divider(height: 20),
              // メモ内容
              Expanded(
                child: SingleChildScrollView(
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: Colors.blue.withOpacity(0.05),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(color: Colors.blue.withOpacity(0.2)),
                    ),
                    child: Text(
                      memo,
                      style: const TextStyle(
                        fontSize: 16,
                        color: Colors.black87,
                        height: 1.6,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 20),
              // フッターボタン
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('閉じる'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  // ページネーション機能（大量データ対応）
  static const int _pageSize = 20; // 1ページあたりの件数
  int _currentPage = 0;
  List<MedicationMemo> _displayedMemos = [];
  bool _isLoadingMore = false;
  final ScrollController _memoScrollController = ScrollController();
  
  // アラーム制限機能
  static const int maxAlarms = 100; // アラーム上限
  static const int maxMemos = 1000; // メモ上限

  // Hive最適化データベースサービス（大量データ対応）
  static Box<MedicationMemo>? _memoBox;
  
  static Future<Box<MedicationMemo>> get _getMemoBox async {
    if (_memoBox != null) return _memoBox!;
    _memoBox = await Hive.openBox<MedicationMemo>('medication_memos');
    return _memoBox!;
  }
  
  // ページネーション付きメモ取得
  static Future<List<MedicationMemo>> getMemos({
    int limit = 20,
    int offset = 0,
  }) async {
    final box = await _getMemoBox;
    final allMemos = box.values.toList();
    allMemos.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    return allMemos.skip(offset).take(limit).toList();
  }
  
  // 検索機能
  static Future<List<MedicationMemo>> searchMemos(String keyword) async {
    final box = await _getMemoBox;
    return box.values
        .where((memo) => memo.name.toLowerCase().contains(keyword.toLowerCase()))
        .take(50)
        .toList();
  }
  
  // メモ保存
  static Future<void> saveMemo(MedicationMemo memo) async {
    final box = await _getMemoBox;
    await box.put(memo.id, memo);
  }
  
  // メモ削除
  static Future<void> deleteMemo(String id) async {
    final box = await _getMemoBox;
    await box.delete(id);
  }
  
  // リアクティブストリーム
  static Stream<List<MedicationMemo>> watchMemos() async* {
    final box = await _getMemoBox;
    yield box.values.toList();
    yield* box.watch().map((_) => box.values.toList());
  }

  // 統一データサービス（重複削除）
  Future<void> _saveAllDataUnified() async {
    try {
      await Future.wait([
        _saveMedicationData(),
        _saveMemoStatus(),
        _saveAlarmData(),
        _saveUserPreferences(),
        _saveAppSettings(),
      ]);
      debugPrint('統一データサービス: 全データ保存完了');
    } catch (e) {
      debugPrint('統一データサービス保存エラー: $e');
    }
  }
  
  Future<void> _loadAllDataUnified() async {
    try {
      await Future.wait([
        _loadMedicationData(),
        _loadMemoStatus(),
        _loadAlarmData(),
        _loadUserPreferences(),
        _loadAppSettings(),
      ]);
      debugPrint('統一データサービス: 全データ読み込み完了');
    } catch (e) {
      debugPrint('統一データサービス読み込みエラー: $e');
    }
  }

  // ページネーション機能の実装
  Future<void> _loadMoreMemos() async {
    if (_isLoadingMore || _currentPage * _pageSize >= _medicationMemos.length) return;
    
    setState(() => _isLoadingMore = true);
    
    // ページングで一部だけ読み込み
      final startIndex = _currentPage * _pageSize;
      final endIndex = (startIndex + _pageSize).clamp(0, _medicationMemos.length);
      
      if (startIndex < _medicationMemos.length) {
        final newMemos = _medicationMemos.sublist(startIndex, endIndex);
        
        setState(() {
          _displayedMemos.addAll(newMemos);
          _currentPage++;
          _isLoadingMore = false;
        });
      } else {
        setState(() => _isLoadingMore = false);
    }
  }
  
  // スクロール監視の初期化
  void _initializeScrollListener() {
    _memoScrollController.addListener(() {
      if (_memoScrollController.position.pixels >= 
          _memoScrollController.position.maxScrollExtent * 0.8) {
        _loadMoreMemos();
      }
    });
  }
  
  // アラーム制限チェック
  bool _canAddAlarm() {
    return _alarmList.length < maxAlarms;
  }
  
  // メモ制限チェック
  bool _canAddMemo() {
    return _medicationMemos.length < maxMemos;
  }
  
  // 制限ダイアログ表示
  void _showLimitDialog(String type) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            const Icon(Icons.warning, color: Colors.orange),
            const SizedBox(width: 8),
            Text('${type}上限'),
          ],
        ),
        content: Text('${type}は最大${type == 'アラーム' ? maxAlarms : maxMemos}件まで設定できます。\n不要な${type}を削除してください。'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('了解'),
          ),
        ],
      ),
    );
  }

  // 服用済みに追加（簡素化版）
  void _addToTakenMedications(MedicationMemo memo) {
    if (_selectedDay == null) return;
    
    // 重複チェック
    final existingIndex = _addedMedications.indexWhere((med) => med['id'] == memo.id);
    
    if (existingIndex == -1) {
      // 新規追加
      _addedMedications.add({
        'id': memo.id,
        'name': memo.name,
        'type': memo.type,
        'dosage': memo.dosage,
        'color': memo.color,
        'taken': true,
        'takenTime': DateTime.now(),
        'notes': memo.notes,
      });
    } else {
      // 既存のものを更新
      _addedMedications[existingIndex]['taken'] = true;
      _addedMedications[existingIndex]['takenTime'] = DateTime.now();
    }
    
    // メモの状態を更新
    _medicationMemoStatus[memo.id] = true;
    
    // カレンダーマークを追加（服用状況に反映）
    if (_selectedDay != null) {
      if (!_selectedDates.contains(_selectedDay!)) {
        _selectedDates.add(_selectedDay!);
      }
    }
    
    // データ保存のみ
    _saveAllData();
  }
  
  // 服用済みから削除（簡素化版）
  void _removeFromTakenMedications(String memoId) {
    _addedMedications.removeWhere((med) => med['id'] == memoId);
    
    // その日の服用メモがすべてチェックされていない場合、カレンダーマークを削除
    if (_selectedDay != null) {
      final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
      final hasCheckedMemos = _medicationMemoStatus.values.any((status) => status);
      if (!hasCheckedMemos && _addedMedications.isEmpty) {
        _selectedDates.remove(dateStr);
      }
    }
    
    // データ保存のみ
    _saveAllData();
  }
  
  // 服用メモの状態を更新
  void _updateMedicationMemoStatus(String memoId, bool isChecked) {
    setState(() {
      _medicationMemoStatus[memoId] = isChecked;
    });
    // データ保存
    _saveAllData();
  }
  
  // こぱさん流：服用データを保存（確実なデータ保持）
  Future<void> _saveMedicationData() async {
    try {
      if (_selectedDay != null) {
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
        final medicationData = <String, MedicationInfo>{};
        
        // _addedMedicationsからMedicationInfoを作成
        for (final med in _addedMedications) {
          final name = med['name']?.toString() ?? '';
          final taken = med['taken'] is bool ? med['taken'] as bool : false;
          final takenTime = med['takenTime'] is DateTime ? med['takenTime'] as DateTime? : null;
          final notes = med['notes']?.toString() ?? '';
          
          medicationData[name] = MedicationInfo(
            checked: taken,
            medicine: name,
            actualTime: takenTime,
            notes: notes,
          );
        }
        
        // こぱさん流：awaitを確実に付けて保存
        await MedicationService.saveMedicationData({dateStr: medicationData});
        await _saveToSharedPreferences(dateStr, medicationData);
        await _saveMemoStatus();
        await _saveAdditionalBackup(dateStr, medicationData);
        
        // 服用薬データも保存
        await _saveMedicationList();
        
        // アラームデータも保存
        await _saveAlarmData();
        
        debugPrint('全データ保存完了: $dateStr（こぱさん流）');
      }
    } catch (e) {
      debugPrint('データ保存エラー: $e');
    }
  }
  
  // 追加のバックアップ保存
  Future<void> _saveAdditionalBackup(String dateStr, Map<String, MedicationInfo> data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final dataJson = <String, dynamic>{};
      
      for (final entry in data.entries) {
        dataJson[entry.key] = entry.value.toJson();
      }
      
      // 複数のバックアップキーで保存
      await prefs.setString('medication_backup_$dateStr', jsonEncode(dataJson));
      await prefs.setString('medication_backup_latest', jsonEncode(dataJson));
      await prefs.setString('last_save_date', dateStr);
      await prefs.setString('last_save_timestamp', DateTime.now().toIso8601String());
      
      // 強制的にフラッシュ
      await prefs.commit();
      
      debugPrint('追加バックアップ保存完了: $dateStr');
    } catch (e) {
      debugPrint('追加バックアップ保存エラー: $e');
    }
  }
  
  // こぱさん流：服用薬データを保存（確実なデータ保持）
  Future<void> _saveMedicationList() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final medicationListJson = <String, dynamic>{};
      
      // 服用薬リストを保存
      for (int i = 0; i < _addedMedications.length; i++) {
        final med = _addedMedications[i];
        medicationListJson['medication_$i'] = {
          'id': med['id'],
          'name': med['name'],
          'type': med['type'],
          'dosage': med['dosage'],
          'color': med['color'],
          'taken': med['taken'],
          'takenTime': med['takenTime']?.toIso8601String(),
          'notes': med['notes'],
        };
      }
      
      // こぱさん流：awaitを確実に付けて保存
      await prefs.setString('medicationList', jsonEncode(medicationListJson));
      await prefs.setString('medicationList_backup', jsonEncode(medicationListJson));
      await prefs.setInt('medicationList_count', _addedMedications.length);
      
      debugPrint('服用薬データ保存完了: ${_addedMedications.length}件（こぱさん流）');
    } catch (e) {
      debugPrint('服用薬データ保存エラー: $e');
    }
  }
  
  // 確実なアラームデータ保存（指定パス方式を採用）
  Future<void> _saveAlarmData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // アラーム数を保存
      await prefs.setInt('alarm_count', _alarmList.length);
      
      // 各アラームのデータを個別に保存（指定パス方式）
      for (int i = 0; i < _alarmList.length; i++) {
        final alarm = _alarmList[i];
        await prefs.setString('alarm_${i}_name', alarm['name'] ?? '');
        await prefs.setString('alarm_${i}_time', alarm['time'] ?? '00:00');
        await prefs.setString('alarm_${i}_repeat', alarm['repeat'] ?? '一度だけ');
        await prefs.setBool('alarm_${i}_enabled', alarm['enabled'] ?? true);
        await prefs.setString('alarm_${i}_alarmType', alarm['alarmType'] ?? 'sound');
        await prefs.setInt('alarm_${i}_volume', alarm['volume'] ?? 80);
        await prefs.setString('alarm_${i}_message', alarm['message'] ?? '薬を服用する時間です');
      }
      
      // バックアップも保存
      await prefs.setString('alarm_backup_count', _alarmList.length.toString());
      await prefs.setString('alarm_last_save', DateTime.now().toIso8601String());
      
      debugPrint('アラームデータ保存完了: ${_alarmList.length}件（指定パス方式）');
    } catch (e) {
      debugPrint('アラームデータ保存エラー: $e');
    }
  }
  
  // SharedPreferencesにバックアップ保存
  Future<void> _saveToSharedPreferences(String dateStr, Map<String, MedicationInfo> data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final dataJson = <String, dynamic>{};
      
      for (final entry in data.entries) {
        dataJson[entry.key] = entry.value.toJson();
      }
      
      await prefs.setString('medication_backup_$dateStr', jsonEncode(dataJson));
      await prefs.setString('last_save_date', dateStr);
      debugPrint('SharedPreferencesバックアップ保存完了: $dateStr');
    } catch (e) {
      debugPrint('SharedPreferences保存エラー: $e');
    }
  }
  
  // 🔴 最重要：メモの状態を保存（完全版）
  Future<void> _saveMemoStatus() async {
    try {
      final memoStatusJson = <String, dynamic>{};
      
      for (final entry in _medicationMemoStatus.entries) {
        memoStatusJson[entry.key] = entry.value;
      }
      
      // 🔴 最重要：awaitを確実に付けて保存
      await AppPreferences.saveString('medicationMemoStatus', jsonEncode(memoStatusJson));
      await AppPreferences.saveString('medication_memo_status', jsonEncode(memoStatusJson));
      await AppPreferences.saveString('memo_status_backup', jsonEncode(memoStatusJson));
      await AppPreferences.saveString('last_memo_save', DateTime.now().toIso8601String());
      
      debugPrint('メモ状態保存完了: ${memoStatusJson.length}件（完全版）');
    } catch (e) {
      debugPrint('メモ状態保存エラー: $e');
    }
  }
  
  // 🔴 最重要：メモの状態を読み込み（完全版）
  Future<void> _loadMemoStatus() async {
    try {
      String? memoStatusStr;
      
      // 🔴 最重要：複数キーから読み込み（優先順位付き）
      final keys = ['medicationMemoStatus', 'medication_memo_status', 'memo_status_backup'];
      
      for (final key in keys) {
        memoStatusStr = AppPreferences.getString(key);
        if (memoStatusStr != null && memoStatusStr.isNotEmpty) {
          debugPrint('メモ状態読み込み成功: $key（完全版）');
          break;
        }
      }
      
      if (memoStatusStr != null && memoStatusStr.isNotEmpty) {
        final memoStatusJson = jsonDecode(memoStatusStr) as Map<String, dynamic>;
        _medicationMemoStatus = memoStatusJson.map((key, value) => MapEntry(key, value as bool));
        debugPrint('メモ状態読み込み完了: ${_medicationMemoStatus.length}件');
        
        // 🔴 最重要：UIに反映
        if (mounted) {
    setState(() {
            // 保存された値があればそれを使う
          });
        }
      } else {
        debugPrint('メモ状態データが見つかりません（初期値を使用）');
        _medicationMemoStatus = {};
      }
    } catch (e) {
      debugPrint('メモ状態読み込みエラー: $e');
      _medicationMemoStatus = {};
    }
  }

  // 服用メモのチェック状態を取得
  bool _getMedicationMemoStatus(String memoId) {
    return _medicationMemoStatus[memoId] ?? false;
  }
  
  // 選択された日付の服用メモのチェック状態を取得
  bool _getMedicationMemoStatusForSelectedDay(String memoId) {
    if (_selectedDay == null) return false;
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    return _weekdayMedicationStatus[dateStr]?[memoId] ?? false;
  }
  
  // 指定日のメモの服用回数別チェック状況を取得
  bool _getMedicationMemoDoseStatusForSelectedDay(String memoId, int doseIndex) {
    if (_selectedDay == null) return false;
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    return _weekdayMedicationDoseStatus[dateStr]?[memoId]?[doseIndex] ?? false;
  }
  
  // 指定日のメモの服用済み回数を取得
  int _getMedicationMemoCheckedCountForSelectedDay(String memoId) {
    if (_selectedDay == null) return 0;
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    final doseStatus = _weekdayMedicationDoseStatus[dateStr]?[memoId];
    if (doseStatus == null) return 0;
    return doseStatus.values.where((isChecked) => isChecked).length;
  }
  
  // アプリ再起動時のデータ表示を確実にする
  Future<void> _ensureDataDisplayOnRestart() async {
    try {
      // データ読み込み完了を待つ
      await Future.delayed(const Duration(milliseconds: 100));
      
      // 選択された日付のデータを確認
      if (_selectedDay != null) {
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
        debugPrint('再起動後データ表示確認: $dateStr');
        
        // 服用メモの状態を再確認
        for (final memo in _medicationMemos) {
          if (!_medicationMemoStatus.containsKey(memo.id)) {
            _medicationMemoStatus[memo.id] = false;
          }
        }
        
        // UIを強制更新
        if (mounted) {
    setState(() {
            // データ表示を確実にする
          });
        }
        
        debugPrint('再起動後データ表示完了: メモ${_medicationMemos.length}件, 状態${_medicationMemoStatus.length}件');
      }
    } catch (e) {
      debugPrint('再起動後データ表示エラー: $e');
    }
  }


  // 完全に作り直された服用記録リスト
  Widget _buildAddedMedicationRecord(Map<String, dynamic> medication) {
    final isChecked = medication['isChecked'] ?? false;
    final medicationName = medication['name'] ?? '';
    final medicationType = medication['type'] ?? '';
    final medicationColor = medication['color'] ?? Colors.blue;
    
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        border: isChecked
            ? Border.all(color: Colors.green, width: 2)
            : Border.all(color: Colors.grey.withOpacity(0.3)),
        boxShadow: [
          BoxShadow(
            color: isChecked 
                ? Colors.green.withOpacity(0.3)
                : Colors.grey.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          gradient: isChecked
              ? LinearGradient(
                  colors: [Colors.green.withOpacity(0.05), Colors.green.withOpacity(0.02)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                )
              : null,
        ),
        child: Padding(
          padding: const EdgeInsets.all(24), // パディングを増加
          child: Row(
            children: [
              // 完全に作り直された服用済みチェックボックス
              GestureDetector(
                onTap: () async {
                  // ✅ 追加：変更前スナップショット（状態変更前）
                  if (_selectedDay != null) {
                    await _saveSnapshotBeforeChange('服用チェック_${medicationName}_${DateFormat('yyyy-MM-dd').format(_selectedDay!)}');
                  }
                  
                  // 強制的に状態を更新
                  setState(() {
                    medication['isChecked'] = !isChecked;
                  });
                  
                  // データを即座に保存（遅延なし）
                  _saveCurrentData();
                  
                  // カレンダーマークを更新
                  _updateCalendarMarks();
                  
                  // 統計を強制再計算
                  setState(() {
                    // 統計を強制再計算
                  });
                },
                child: Container(
                  width: 60, // サイズを大きく
                  height: 60,
                  decoration: BoxDecoration(
                    color: isChecked ? Colors.green : Colors.grey.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                    boxShadow: isChecked
                        ? [
                            BoxShadow(
                              color: Colors.green.withOpacity(0.3),
                              spreadRadius: 1,
                              blurRadius: 4,
                              offset: const Offset(0, 2),
                            ),
                          ]
                        : null,
                  ),
                  child: Icon(
                    isChecked ? Icons.check_circle : Icons.radio_button_unchecked,
                    color: isChecked ? Colors.white : Colors.grey,
                    size: 30,
                  ),
                ),
              ),
              const SizedBox(width: 24), // 間隔を広く
              // 薬の情報
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          medicationType == 'サプリメント' ? Icons.eco : Icons.medication,
                          color: isChecked ? Colors.green : medicationColor,
                          size: 20,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          medicationName,
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: isChecked ? Colors.green : const Color(0xFF2196F3),
                          ),
                        ),
                        if (isChecked) ...[
                          const SizedBox(width: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: Colors.green,
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: const Text(
                              '服用済み',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                        ],
                      ],
                    ),
                    const SizedBox(height: 8),
                    Text(
                      medicationType,
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey[600],
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
              // 削除ボタン
              IconButton(
                onPressed: () async {
                  // ✅ 追加：変更前スナップショット
                  if (_selectedDay != null) {
                    await _saveSnapshotBeforeChange('服用記録削除_${medicationName}_${DateFormat('yyyy-MM-dd').format(_selectedDay!)}');
                  }
                  setState(() {
                    _addedMedications.remove(medication);
                  });
                  // データを即座に保存（遅延なし）
                  _saveCurrentData();
                },
                icon: const Icon(Icons.delete, color: Colors.red),
                tooltip: '削除',
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMedicineTab() {
    return Padding(
        padding: const EdgeInsets.all(12),
        child: Card(
          elevation: 4,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
          child: Container(
            padding: const EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.max, // 最大高さを使用
              children: [
                Text(
                  '服用メモ',
                  style: TextStyle(
                    fontSize: 24, 
                    fontWeight: FontWeight.bold,
                    color: Theme.of(context).brightness == Brightness.dark 
                        ? Colors.white 
                        : Colors.black87,
                  ),
                ),
                const SizedBox(height: 16),
            // 服用メモリスト（無限スクロール対応・高さ最適化）
            Expanded(
              flex: 1, // 残りの高さを全て使用
              child: _medicationMemos.isEmpty
                      ? const Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(Icons.note_alt_outlined, size: 72, color: Colors.grey),
                              SizedBox(height: 12),
                              Text(
                                '服用メモがまだありません',
                                style: TextStyle(fontSize: 16),
                              ),
                              SizedBox(height: 8),
                              Text(
                                '右下の+マークから新しいメモを追加できます。',
                                textAlign: TextAlign.center,
                                style: TextStyle(fontSize: 13),
                              ),
                            ],
                          ),
                        )
                      : ListView.builder(
                          controller: _memoScrollController,
                          physics: const BouncingScrollPhysics(),
                      itemCount: _medicationMemos.length,
                          // 無限スクロール用の最適化設定
                          cacheExtent: 1000, // キャッシュ範囲を拡張（パフォーマンス向上）
                          addAutomaticKeepAlives: true, // 自動的にKeepAliveを追加
                          addRepaintBoundaries: true, // 再描画境界を追加
                          addSemanticIndexes: true, // セマンティックインデックスを追加
                          // スクロール動作の最適化
                          shrinkWrap: true, // コンテンツに応じて高さを調整
                          primary: false, // 高さ無制限のためfalseに設定
                          itemBuilder: (context, index) {
                        final memo = _medicationMemos[index];
                            return Card(
                              margin: const EdgeInsets.symmetric(vertical: 10, horizontal: 4),
                              elevation: 4,
                              shadowColor: Colors.black.withOpacity(0.2),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Padding(
                                padding: const EdgeInsets.all(18),
                                child: Column(
                                  children: [
                                    // アイコンと名前を上に配置
                                    Row(
                                      children: [
                                        CircleAvatar(
                                          backgroundColor: memo.color,
                                          radius: 24,
                                          child: Icon(
                                            memo.type == 'サプリメント' ? Icons.eco : Icons.medication,
                                            color: Colors.white,
                                            size: 24,
                                          ),
                                        ),
                                        const SizedBox(width: 12),
                                        Expanded(
                                          child: Column(
                                            crossAxisAlignment: CrossAxisAlignment.start,
                                            children: [
                                              Text(
                                                memo.name,
                                                style: TextStyle(
                                                  fontSize: 18,
                                                  fontWeight: FontWeight.bold,
                                                  color: Theme.of(context).brightness == Brightness.dark 
                                                      ? Colors.white 
                                                      : Colors.black87,
                                                ),
                                              ),
                                              const SizedBox(height: 4),
                                              Container(
                                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                                decoration: BoxDecoration(
                                                  color: memo.type == 'サプリメント'
                                                      ? Colors.green.withOpacity(0.1)
                                                      : Colors.blue.withOpacity(0.1),
                                                  borderRadius: BorderRadius.circular(12),
                                                  border: Border.all(
                                                    color: memo.type == 'サプリメント'
                                                        ? Colors.green.withOpacity(0.3)
                                                        : Colors.blue.withOpacity(0.3),
                                                  ),
                                                ),
                                                child: Text(
                                                  memo.type,
                                                  style: TextStyle(
                                                    fontSize: 12,
                                                    fontWeight: FontWeight.w500,
                                                    color: Theme.of(context).brightness == Brightness.dark 
                                                        ? Colors.white70 
                                                        : (memo.type == 'サプリメント' ? Colors.green : Colors.blue),
                                                  ),
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                        // アクションボタンを右上に配置
                                        PopupMenuButton<String>(
                                          onSelected: (value) async {
                                            // トライアル制限チェック
                                            final isExpired = await TrialService.isTrialExpired();
                                  if (isExpired) {
                                    showDialog(
                                      context: context,
                                      builder: (context) => TrialLimitDialog(featureName: '服用メモ'),
                                    );
                                    return;
                                  }
                                  switch (value) {
                                    case 'taken':
                                      _markAsTaken(memo);
                                      break;
                                    case 'edit':
                                      _editMemo(memo);
                                      break;
                                    case 'delete':
                                      _deleteMemo(memo.id);
                                      break;
                                  }
                                },
                                itemBuilder: (context) => [
                                  const PopupMenuItem(
                                    value: 'taken',
                                    child: Row(
                                      children: [
                                        Icon(Icons.check_circle, color: Colors.green),
                                        SizedBox(width: 8),
                                        Text('服用記録'),
                                      ],
                                    ),
                                  ),
                                  const PopupMenuItem(
                                    value: 'edit',
                                    child: Row(
                                      children: [
                                        Icon(Icons.edit, color: Colors.blue),
                                        SizedBox(width: 8),
                                        Text('編集'),
                                      ],
                                    ),
                                  ),
                                  const PopupMenuItem(
                                    value: 'delete',
                                    child: Row(
                                      children: [
                                        Icon(Icons.delete, color: Colors.red),
                                        SizedBox(width: 8),
                                        Text('削除'),
                                      ],
                                    ),
                                  ),
                                ],
                                child: const Icon(Icons.more_vert),
                              ),
                            ],
                          ),
                          const SizedBox(height: 14),
                          // 詳細情報を下に配置
                          Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // 服用回数情報
                              Container(
                                width: double.infinity,
                                padding: const EdgeInsets.all(14),
                                decoration: BoxDecoration(
                                  color: Colors.blue.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: Row(
                                  children: [
                                    const Icon(Icons.repeat, size: 16, color: Colors.blue),
                                    const SizedBox(width: 8),
                                    Text(
                                      '服用回数: ${memo.dosageFrequency}回',
                                      style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                                    ),
                                    if (memo.dosageFrequency >= 6) ...[
                                      const SizedBox(width: 8),
                                      GestureDetector(
                                        onTap: () {
                                          _showWarningDialog(context);
                                        },
                                        child: const Icon(Icons.warning, size: 16, color: Colors.orange),
                                      ),
                                    ],
                                  ],
                                ),
                              ),
                              const SizedBox(height: 10),
                              if (memo.dosage.isNotEmpty)
                                Container(
                                  width: double.infinity,
                                  padding: const EdgeInsets.all(14),
                                  decoration: BoxDecoration(
                                    color: Colors.grey.withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  child: Row(
                                    children: [
                                      const Icon(Icons.straighten, size: 16, color: Colors.grey),
                                      const SizedBox(width: 8),
                                      Text(
                                        '用量: ${memo.dosage}',
                                        style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                                      ),
                                    ],
                                  ),
                                ),
                              if (memo.dosage.isNotEmpty) const SizedBox(height: 10),
                              if (memo.notes.isNotEmpty)
                                Container(
                                  width: double.infinity,
                                  padding: const EdgeInsets.all(14),
                                  decoration: BoxDecoration(
                                    color: Colors.blue.withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  child: Row(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      const Icon(Icons.note, size: 16, color: Colors.blue),
                                      const SizedBox(width: 8),
                                      Expanded(
                                        child: Text(
                                          memo.notes,
                                          style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              if (memo.notes.isNotEmpty) const SizedBox(height: 10),
                              // ✅ 改善版：曜日未設定の警告表示（目立つデザイン）
                              if (memo.selectedWeekdays.isEmpty)
                                Container(
                                  width: double.infinity,
                                  padding: const EdgeInsets.all(20),
                                  decoration: BoxDecoration(
                                    gradient: LinearGradient(
                                      colors: [
                                        Colors.red.withOpacity(0.15),
                                        Colors.orange.withOpacity(0.15),
                                      ],
                                      begin: Alignment.topLeft,
                                      end: Alignment.bottomRight,
                                    ),
                                    borderRadius: BorderRadius.circular(12),
                                    border: Border.all(
                                      color: Colors.red.withOpacity(0.5),
                                      width: 2,
                                    ),
                                    boxShadow: [
                                      BoxShadow(
                                        color: Colors.red.withOpacity(0.2),
                                        spreadRadius: 2,
                                        blurRadius: 8,
                                        offset: const Offset(0, 3),
                                      ),
                                    ],
                                  ),
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Row(
                                        children: [
                                          Container(
                                            padding: const EdgeInsets.all(8),
                                            decoration: BoxDecoration(
                                              color: Colors.red.withOpacity(0.2),
                                              shape: BoxShape.circle,
                                            ),
                                            child: const Icon(
                                              Icons.warning_amber_rounded, 
                                              size: 28, 
                                              color: Colors.red,
                                            ),
                                          ),
                                          const SizedBox(width: 12),
                                      const Expanded(
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                                  '⚠️ 服用スケジュール未設定',
                                                  style: TextStyle(
                                                    fontSize: 18, 
                                                    color: Colors.red, 
                                                    fontWeight: FontWeight.bold,
                                                  ),
                                                ),
                                                SizedBox(height: 4),
                                                Text(
                                                  '曜日を設定してください',
                                              style: TextStyle(
                                                fontSize: 14, 
                                                color: Colors.orange, 
                                                    fontWeight: FontWeight.w600,
                                                  ),
                                                ),
                                              ],
                                            ),
                                          ),
                                        ],
                                      ),
                                      const SizedBox(height: 12),
                                      Container(
                                        padding: const EdgeInsets.all(12),
                                        decoration: BoxDecoration(
                                          color: Colors.white.withOpacity(0.7),
                                          borderRadius: BorderRadius.circular(8),
                                        ),
                                        child: Row(
                                          children: [
                                            const Icon(Icons.info_outline, size: 18, color: Colors.blue),
                                            const SizedBox(width: 8),
                                            Expanded(
                                              child: Text(
                                                'メモを編集して「服用スケジュール」から(毎日、曜日)を選択してください',
                                                style: TextStyle(
                                                  fontSize: 13,
                                                  color: Colors.grey[800],
                                                  height: 1.4,
                                                ),
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              if (memo.selectedWeekdays.isEmpty) const SizedBox(height: 10),
                              if (memo.lastTaken != null)
                                Container(
                                  width: double.infinity,
                                  padding: const EdgeInsets.all(14),
                                  decoration: BoxDecoration(
                                    color: Colors.green.withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  child: Row(
                                    children: [
                                      const Icon(Icons.schedule, size: 16, color: Colors.green),
                                      const SizedBox(width: 8),
                                      Text(
                                        '最後の服用:\n${DateFormat('yyyy/MM/dd HH:mm').format(memo.lastTaken!)}',
                                        style: const TextStyle(fontSize: 14, color: Colors.green, fontWeight: FontWeight.w500),
                                        textAlign: TextAlign.center,
                                      ),
                                    ],
                                  ),
                                ),
                            ],
                          ),
                        ],
                      ),
                    ),
                      );
                    },
                  ),
            ),
          ],
          ),
        ),
      ),
    );
  }

  Widget _buildAlarmTab() {
    return FutureBuilder<bool>(
      future: TrialService.isTrialExpired(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        final isExpired = snapshot.data ?? false;
        
        if (isExpired) {
          return Center(
            child: Padding(
              padding: const EdgeInsets.all(32),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.lock, size: 80, color: Colors.orange),
                  SizedBox(height: 24),
                  Text(
                    'トライアル期間が終了しました',
                    style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                    textAlign: TextAlign.center,
                  ),
                  SizedBox(height: 16),
                  Text(
                    'アラーム機能は制限されています',
                    style: TextStyle(fontSize: 16),
                    textAlign: TextAlign.center,
                  ),
                  SizedBox(height: 32),
                  ElevatedButton.icon(
                    onPressed: () async {
                      await TrialService.getPurchaseLink();
                      // リンクを開く処理（後で実装）
                    },
                    icon: Icon(Icons.shopping_cart),
                    label: Text('👉 機能解除はこちら'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.blue,
                      foregroundColor: Colors.white,
                      padding: EdgeInsets.symmetric(horizontal: 24, vertical: 16),
                      textStyle: TextStyle(fontSize: 16),
                    ),
                  ),
                ],
              ),
            ),
          );
        }
        
        return KeyedSubtree(
          key: _alarmTabKey,  // ✅ キーを設定
          child: const SimpleAlarmApp(),
        );
      },
    );
  }


  Widget _buildStatsTab() {
    return FutureBuilder<bool>(
      future: TrialService.isTrialExpired(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        
        final isExpired = snapshot.data ?? false;
        
        if (isExpired) {
          return Center(
            child: Padding(
              padding: const EdgeInsets.all(32),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.lock, size: 80, color: Colors.orange),
                  SizedBox(height: 24),
                  Text(
                    'トライアル期間が終了しました',
                    style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                    textAlign: TextAlign.center,
                  ),
                  SizedBox(height: 16),
                  Text(
                    '統計機能は制限されています',
                    style: TextStyle(fontSize: 16),
                    textAlign: TextAlign.center,
                  ),
                  SizedBox(height: 32),
                  ElevatedButton.icon(
                    onPressed: () async {
                      await TrialService.getPurchaseLink();
                      // リンクを開く処理（後で実装）
                    },
                    icon: Icon(Icons.shopping_cart),
                    label: Text('👉 機能解除はこちら'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.blue,
                      foregroundColor: Colors.white,
                      padding: EdgeInsets.symmetric(horizontal: 24, vertical: 16),
                      textStyle: TextStyle(fontSize: 16),
                    ),
                  ),
                ],
              ),
            ),
          );
        }
        
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Card(
        elevation: 4,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        child: Container(
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisSize: MainAxisSize.max, // 最大高さを使用
            children: [
              const Text(
                '服薬遵守率',
                style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 20),
              Expanded(
                flex: 1, // 残りの高さを全て使用
                child: SingleChildScrollView(
                  controller: _statsScrollController,
                  physics: const BouncingScrollPhysics(),
                  child: Column(
                  children: [
                    // 遵守率グラフ
                    _buildAdherenceChart(),
                    const SizedBox(height: 20),
                    // 薬品別使用状況グラフ
                    _buildMedicationUsageChart(),
                    const SizedBox(height: 20),
                    // 期間別遵守率カード
                    ..._adherenceRates.entries.map((entry) => _buildStatCard(entry.key, entry.value)).toList(),
                      const SizedBox(height: 20),
                      // 任意の日数の遵守率カード
                    _buildCustomAdherenceCard(),
                  ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
        );
      },
    );
  }
  Widget _buildStatCard(String period, double rate) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(period, style: const TextStyle(fontSize: 18)),
            Text(
              '${rate.toStringAsFixed(1)}%',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: rate >= 80 ? Colors.green : rate >= 60 ? Colors.orange : Colors.red,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  // ✅ 任意の日数の遵守率カード（別画面へのナビゲーション）
  Widget _buildCustomAdherenceCard() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.analytics, color: Colors.blue, size: 24),
                const SizedBox(width: 12),
                const Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
              '任意の日数の遵守率',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
                      Text(
                        '指定した期間の遵守率を分析',
                        style: TextStyle(fontSize: 14, color: Colors.grey),
                      ),
                    ],
                  ),
                ),
                ElevatedButton.icon(
                  onPressed: () {
                    _showCustomAdherenceDialog();
                  },
                  icon: const Icon(Icons.calculate),
                  label: const Text('分析'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue,
                    foregroundColor: Colors.white,
                  ),
                ),
              ],
            ),
            if (_customAdherenceResult != null) ...[
            const SizedBox(height: 16),
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: _customAdherenceResult! >= 80
                      ? Colors.green.withOpacity(0.1)
                      : _customAdherenceResult! >= 60
                          ? Colors.orange.withOpacity(0.1)
                          : Colors.red.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: _customAdherenceResult! >= 80
                        ? Colors.green
                        : _customAdherenceResult! >= 60
                            ? Colors.orange
                            : Colors.red,
                    width: 2,
                  ),
                ),
                child: Column(
              children: [
                    Text(
                      '${_customDaysResult}日間の遵守率',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      '${_customAdherenceResult!.toStringAsFixed(1)}%',
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: _customAdherenceResult! >= 80
                            ? Colors.green
                            : _customAdherenceResult! >= 60
                                ? Colors.orange
                                : Colors.red,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
  
  // ✅ カスタム遵守率ダイアログ表示
  void _showCustomAdherenceDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: Row(
                children: [
                  const Icon(Icons.analytics, color: Colors.blue, size: 20),
                  const SizedBox(width: 8),
                  const Expanded(
                    child: Text(
                      '任意の日数の遵守率',
                      style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                  ),
                ],
              ),
              content: SizedBox(
                width: double.maxFinite,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Text(
                      '分析したい期間の日数を入力してください',
                      style: TextStyle(fontSize: 14),
                    ),
                    const SizedBox(height: 20),
                    TextField(
                    controller: _customDaysController,
                      focusNode: _customDaysFocusNode,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                        labelText: '日数（1-365日）',
                        hintText: '例: 30',
                      border: OutlineInputBorder(),
                      prefixIcon: Icon(Icons.calendar_today),
                        helperText: '過去何日間のデータを分析しますか？',
                    ),
                    onChanged: (value) {
                        // 入力値の検証
                      },
                    ),
                    const SizedBox(height: 20),
            if (_customAdherenceResult != null) ...[
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: _customAdherenceResult! >= 80
                      ? Colors.green.withOpacity(0.1)
                      : _customAdherenceResult! >= 60
                          ? Colors.orange.withOpacity(0.1)
                          : Colors.red.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: _customAdherenceResult! >= 80
                        ? Colors.green
                        : _customAdherenceResult! >= 60
                            ? Colors.orange
                            : Colors.red,
                    width: 2,
                  ),
                ),
                child: Column(
                  children: [
                    Text(
                      '${_customDaysResult}日間の遵守率',
                      style: const TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      '${_customAdherenceResult!.toStringAsFixed(1)}%',
                      style: TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                        color: _customAdherenceResult! >= 80
                            ? Colors.green
                            : _customAdherenceResult! >= 60
                                ? Colors.orange
                                : Colors.red,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('キャンセル'),
                ),
                ElevatedButton(
                  onPressed: () {
                    final days = int.tryParse(_customDaysController.text);
                    if (days != null && days >= 1 && days <= 365) {
                      _calculateCustomAdherence(days);
                      setDialogState(() {}); // ダイアログ内の状態を更新
                    } else {
                      _showSnackBar('1から365の範囲で日数を入力してください');
                    }
                  },
                  child: const Text('分析実行'),
                ),
              ],
            );
          },
        );
      },
    );
  }
  
  // ✅ カスタム遵守率計算
  void _calculateCustomAdherence(int days) async {
    try {
      // 現在のスクロール位置を保存
      final currentScrollPosition = _statsScrollController.hasClients 
          ? _statsScrollController.offset 
          : 0.0;
      
      // キーボードを閉じる
      _customDaysFocusNode.unfocus();
      FocusScope.of(context).unfocus();
      
      final now = DateTime.now();
      int totalDoses = 0;
      int takenDoses = 0;
      
      for (int i = 0; i < days; i++) {
        final date = now.subtract(Duration(days: i));
        final dateStr = DateFormat('yyyy-MM-dd').format(date);
        final dayData = _medicationData[dateStr];
        
        // 動的薬リストの統計
        if (dayData != null) {
          for (final timeSlot in dayData.values) {
            if (timeSlot.medicine.isNotEmpty) {
              totalDoses++;
              if (timeSlot.checked) takenDoses++;
            }
          }
        }
        
        // 服用メモのチェック状況を統計に反映
        final weekday = date.weekday % 7; // 0=日曜日, 1=月曜日, ..., 6=土曜日
        final weekdayMemos = _medicationMemos.where((memo) => memo.selectedWeekdays.contains(weekday)).toList();
        
        for (final memo in weekdayMemos) {
          totalDoses++;
          // 日付別の服用メモ状態を確認
          if (_weekdayMedicationStatus[dateStr]?[memo.id] == true) {
            takenDoses++;
          }
        }
      }
      
      // データがない場合の警告
      if (totalDoses == 0) {
        _showSnackBar('指定した期間に服薬データがありません');
        return;
      }
      
      final rate = (takenDoses / totalDoses * 100);
     
      // 結果をカード内に表示
      setState(() {
        _customAdherenceResult = rate;
        _customDaysResult = days;
      });
      
      // ダイアログを閉じる
      Navigator.of(context).pop();
      
      // スクロール位置を復元（統計ページの一番下に戻る）
      if (_statsScrollController.hasClients) {
        Future.delayed(const Duration(milliseconds: 300), () {
          _statsScrollController.animateTo(
            _statsScrollController.position.maxScrollExtent,
            duration: const Duration(milliseconds: 500),
            curve: Curves.easeOut,
          );
        });
      }
      
    } catch (e) {
      _showSnackBar('カスタム遵守率の計算に失敗しました: $e');
    }
  }
  
  // 遵守率グラフ
  Widget _buildAdherenceChart() {
    if (_adherenceRates.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              const Text(
                '遵守率グラフ',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 20),
              const Text(
                'データがありません',
                style: TextStyle(fontSize: 16),
              ),
            ],
          ),
        ),
      );
    }
    final chartData = _adherenceRates.entries.toList();
    final maxValue = chartData.map((e) => e.value).reduce((a, b) => a > b ? a : b);
    final minValue = chartData.map((e) => e.value).reduce((a, b) => a < b ? a : b);
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            const Text(
              '遵守率グラフ',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            SizedBox(
              height: 250, // 高さを増加
              child: LineChart(
                LineChartData(
                  gridData: FlGridData(show: true),
                  titlesData: FlTitlesData(
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 50, // 予約サイズを増加
                        getTitlesWidget: (value, meta) {
                          return Padding(
                            padding: const EdgeInsets.only(right: 8),
                            child: Text(
                              '${value.toInt()}%',
                              style: const TextStyle(
                                fontSize: 12,
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        reservedSize: 30, // 予約サイズを追加
                        getTitlesWidget: (value, meta) {
                          if (value.toInt() < chartData.length) {
                            return Padding(
                              padding: const EdgeInsets.only(top: 8),
                              child: Text(
                                chartData[value.toInt()].key,
                                style: const TextStyle(
                                  fontSize: 11,
                                  fontWeight: FontWeight.w500,
                                ),
                                textAlign: TextAlign.center,
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                            );
                          }
                          return const Text('');
                        },
                      ),
                    ),
                    topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                    rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                  ),
                  borderData: FlBorderData(show: true),
                  lineBarsData: [
                    LineChartBarData(
                      spots: chartData.asMap().entries.map((entry) {
                        return FlSpot(entry.key.toDouble(), entry.value.value);
                      }).toList(),
                      isCurved: true,
                      color: Colors.blue,
                      barWidth: 3,
                      dotData: FlDotData(
                        show: true,
                        getDotPainter: (spot, percent, barData, index) {
                          return FlDotCirclePainter(
                            radius: 4,
                            color: Colors.blue,
                            strokeWidth: 2,
                            strokeColor: Colors.white,
                          );
                        },
                      ),
                      belowBarData: BarAreaData(
                        show: true,
                        color: Colors.blue.withOpacity(0.1),
                      ),
                    ),
                  ],
                  minY: minValue - 10,
                  maxY: maxValue + 10,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  // 薬品別使用状況グラフ
  Widget _buildMedicationUsageChart() {
    // 薬品の使用回数を集計（服用メモのチェック状態も含める）
    Map<String, int> medicationCount = {};
    
    // 動的薬リストの統計
    for (final dayData in _medicationData.values) {
      for (final timeSlot in dayData.values) {
        if (timeSlot.medicine.isNotEmpty) {
          medicationCount[timeSlot.medicine] = (medicationCount[timeSlot.medicine] ?? 0) + 1;
        }
      }
    }
    
    // 服用メモのチェック状態を統計に反映（日付別）
    for (final entry in _weekdayMedicationStatus.entries) {
      final dateStr = entry.key;
      final dayStatus = entry.value;
      
      for (final memo in _medicationMemos) {
        if (dayStatus[memo.id] == true) {
          medicationCount[memo.name] = (medicationCount[memo.name] ?? 0) + 1;
        }
      }
    }
    if (medicationCount.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              const Text(
                'くすり、サプリ別使用状況',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 20),
              const Text(
                'データがありません',
                style: TextStyle(fontSize: 16),
              ),
            ],
          ),
        ),
      );
    }
    final sortedMedications = medicationCount.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            const Text(
              'くすり、サプリ別使用状況',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            SizedBox(
              height: 200,
              child: PieChart(
                PieChartData(
                  sections: sortedMedications.asMap().entries.map((entry) {
                    final index = entry.key;
                    final medication = entry.value;
                    final colors = [
                      Colors.blue,
                      Colors.green,
                      Colors.orange,
                      Colors.purple,
                      Colors.red,
                      Colors.teal,
                      Colors.pink,
                      Colors.indigo,
                    ];
                    return PieChartSectionData(
                      color: colors[index % colors.length],
                      value: medication.value.toDouble(),
                      title: '${medication.key}\n${medication.value}回',
                      radius: 60,
                      titleStyle: const TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    );
                  }).toList(),
                  sectionsSpace: 2,
                  centerSpaceRadius: 40,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  Future<void> _applyBulkCheck() async {
    try {
      if (_selectedDates.isEmpty) {
        _showSnackBar('日付を選択してから実行してください。');
        return;
      }
      bool hasData = false;
      // 動的薬リストのチェック
      if (_addedMedications.isNotEmpty) {
        hasData = true;
      }
      if (!hasData) {
        _showSnackBar('薬名または服薬状況を入力してください。');
        return;
      }
      for (final date in _selectedDates) {
        final dateStr = DateFormat('yyyy-MM-dd').format(date);
        _medicationData.putIfAbsent(dateStr, () => {});
        // 動的薬リストのコピー
        for (final medication in _addedMedications) {
          final medicine = medication['name'] as String;
          final checked = medication['isChecked'] as bool;
          _medicationData[dateStr]!['added_medication_${medication.hashCode}'] = MedicationInfo(
            checked: checked,
            medicine: medicine,
            actualTime: checked ? DateTime.now() : null,
          );
          await MedicationService.saveCsvRecord(dateStr, 'added_medication', medicine, checked ? '服薬済み' : '未服薬');
        }
      }
      await MedicationService.saveMedicationData(_medicationData);
      // 通知設定は簡素化
      final notificationTimes = <String, List<TimeOfDay>>{};
      final notificationTypes = <String, NotificationType>{};
      await NotificationService.scheduleNotifications(notificationTimes, _medicationData, notificationTypes);
      setState(() {
        _selectedDates.clear();
        _selectedDay = null;
      });
      _updateMedicineInputsForSelectedDate();
      _showSnackBar('✅ 一括設定を適用しました。');
    } catch (e) {
      _showSnackBar('一括設定の適用に失敗しました: $e');
    }
  }
  Future<void> _applyBulkUncheck() async {
    try {
      if (_selectedDates.isEmpty) {
        _showSnackBar('日付を選択してから実行してください。');
        return;
      }
      for (final date in _selectedDates) {
        final dateStr = DateFormat('yyyy-MM-dd').format(date);
        _medicationData.putIfAbsent(dateStr, () => {});
        // 動的薬リストのコピー
        for (final medication in _addedMedications) {
          final medicine = medication['name'] as String;
          _medicationData[dateStr]!['added_medication_${medication.hashCode}'] = MedicationInfo(
            checked: false,
            medicine: medicine,
            actualTime: null,
          );
          await MedicationService.saveCsvRecord(dateStr, 'added_medication', medicine, '未服薬');
        }
      }
      await MedicationService.saveMedicationData(_medicationData);
      // 通知設定は簡素化
      final notificationTimes = <String, List<TimeOfDay>>{};
      final notificationTypes = <String, NotificationType>{};
      await NotificationService.scheduleNotifications(notificationTimes, _medicationData, notificationTypes);
      setState(() {
        _selectedDates.clear();
        _selectedDay = null;
      });
      _updateMedicineInputsForSelectedDate();
      _showSnackBar('❌ 一括解除を適用しました。');
    } catch (e) {
      _showSnackBar('一括解除の適用に失敗しました: $e');
    }
  }
  Future<void> _deleteMedicine(String name) async {
    try {
      await MedicationService.deleteMedicine(name);
      setState(() {
        _medicines.removeWhere((medicine) => medicine.name == name);
      });
      _showSnackBar('薬品を削除しました');
    } catch (e) {
      _showSnackBar('薬品の削除に失敗しました: $e');
    }
  }
  void _addMemo() {
    showDialog(
      context: context,
      builder: (context) => _MemoDialog(
        existingMemos: _medicationMemos,
        onMemoAdded: (memo) async {
          // ✅ 変更前スナップショット
          await _saveSnapshotBeforeChange('メモ追加_${memo.name.isEmpty ? '無題' : memo.name}');
          try {
            // タイトルが空なら自動連番で補完
            MedicationMemo memoToSave = memo;
            final rawTitle = memo.name.trim();
            if (rawTitle.isEmpty) {
              final titles = _medicationMemos.map((m) => m.name).toList();
              final autoTitle = _generateDefaultTitle(titles);
              memoToSave = MedicationMemo(
                id: memo.id,
                name: autoTitle,
                type: memo.type,
                dosage: memo.dosage,
                notes: memo.notes,
                createdAt: memo.createdAt,
                lastTaken: memo.lastTaken,
                color: memo.color,
                selectedWeekdays: memo.selectedWeekdays,
              );
            }

            // ✅ 改善版：メモを保存（多重バックアップ付き）
            await _saveMedicationMemoWithBackup(memoToSave);
            
            // UIを更新（データ再読み込みは不要）
          setState(() {
            _medicationMemos.add(memoToSave);
              // 新しく追加されたメモを表示リストにも追加
              _displayedMemos.add(memoToSave);
          });
            
            // データを保存
            await _saveAllData();
            
            _showSnackBar('服用メモを追加しました');
          } catch (e) {
            _showSnackBar('メモの追加に失敗しました: $e');
          }
        },
      ),
    );
  }
  void _editMemo(MedicationMemo memo) {
    showDialog(
      context: context,
      builder: (context) => _MemoDialog(
        initialMemo: memo,
        existingMemos: _medicationMemos,
        onMemoAdded: (updatedMemo) async {
          // ✅ 変更前スナップショット
          await _saveSnapshotBeforeChange('メモ編集_${memo.name.isEmpty ? '無題' : memo.name}');
          // タイトルが空なら自動連番で補完
          MedicationMemo memoToSave = updatedMemo;
          final rawTitle = updatedMemo.name.trim();
          if (rawTitle.isEmpty) {
            final titles = _medicationMemos.where((m) => m.id != memo.id).map((m) => m.name).toList();
            final autoTitle = _generateDefaultTitle(titles);
            memoToSave = MedicationMemo(
              id: updatedMemo.id,
              name: autoTitle,
              type: updatedMemo.type,
              dosage: updatedMemo.dosage,
              notes: updatedMemo.notes,
              createdAt: updatedMemo.createdAt,
              lastTaken: updatedMemo.lastTaken,
              color: updatedMemo.color,
              selectedWeekdays: updatedMemo.selectedWeekdays,
            );
          }

          // ✅ 改善版：メモを保存（多重バックアップ付き）
          await _saveMedicationMemoWithBackup(memoToSave);

          setState(() {
            final index = _medicationMemos.indexWhere((m) => m.id == memo.id);
            if (index != -1) {
              _medicationMemos[index] = memoToSave;
            }
            // 表示リストも更新
            final displayedIndex = _displayedMemos.indexWhere((m) => m.id == memo.id);
            if (displayedIndex != -1) {
              _displayedMemos[displayedIndex] = memoToSave;
            }
          });
          
          _showSnackBar('服用メモを更新しました');
        },
      ),
    );
  }
  void _markAsTaken(MedicationMemo memo) async {
    final updatedMemo = MedicationMemo(
      id: memo.id,
      name: memo.name,
      type: memo.type,
      dosage: memo.dosage,
      notes: memo.notes,
      createdAt: memo.createdAt,
      lastTaken: DateTime.now(),
      color: memo.color,
      selectedWeekdays: memo.selectedWeekdays,
    );
    
    // ✅ 改善版：メモを保存（多重バックアップ付き）
    await _saveMedicationMemoWithBackup(updatedMemo);
    
    setState(() {
      final index = _medicationMemos.indexWhere((m) => m.id == memo.id);
      if (index != -1) {
        _medicationMemos[index] = updatedMemo;
      }
    });
    
    _showSnackBar('${memo.name}の服用を記録しました');
  }
  void _deleteMemo(String id) async {
    // ✅ 変更前スナップショット
    final target = _medicationMemos.firstWhere(
      (m) => m.id == id,
      orElse: () => MedicationMemo(
        id: id,
        name: '無題',
        type: '薬品',
        createdAt: DateTime.now(),
      ),
    );
    await _saveSnapshotBeforeChange('メモ削除_${target.name}');
    try {
      // ✅ 改善版：メモを削除（多重バックアップ付き）
      await _deleteMedicationMemoWithBackup(id);
      
      // UIを更新
    setState(() {
      _medicationMemos.removeWhere((memo) => memo.id == id);
        _displayedMemos.removeWhere((memo) => memo.id == id);
        // 関連データも削除
        _medicationMemoStatus.remove(id);
        _weekdayMedicationStatus.remove(id);
        // 日付別の服用状態も削除
        for (final dateStr in _weekdayMedicationDoseStatus.keys) {
          _weekdayMedicationDoseStatus[dateStr]?.remove(id);
        }
      });
      
      // データを保存
      await _saveAllData();
      
    _showSnackBar('メモを削除しました');
    } catch (e) {
      _showSnackBar('削除に失敗しました: $e');
    }
  }

  // 空タイトル時の自動連番生成
  String _generateDefaultTitle(List<String> existingTitles) {
    const int maxCount = 999;
    int count = 1;
    while (count <= maxCount && existingTitles.contains('メモ$count')) {
      count++;
    }
    return 'メモ$count';
  }

  // CSV共有機能の強化（未使用）
  Future<void> _exportToCSV() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final timestamp = DateFormat('yyyyMMdd_HHmmss').format(DateTime.now());
      final file = File('${directory.path}/medication_data_$timestamp.csv');
     
      final csvContent = StringBuffer();
     
      // ヘッダー行
      csvContent.writeln('日付,時間,薬名,服薬状況,実際の服薬時間,遅延時間(分),遵守率');
     
      // 統計情報を計算（服用メモのチェック状態も含める）
      int totalDoses = 0;
      int takenDoses = 0;
      final Map<String, int> medicationCount = {};
      final Map<String, int> medicationTakenCount = {};
     
      // 動的薬リストの統計
      for (final entry in _medicationData.entries) {
        final date = entry.key;
        final dayData = entry.value;
       
        for (final timeSlot in dayData.entries) {
          final time = timeSlot.key;
          final info = timeSlot.value;
         
          if (info.medicine.isNotEmpty) {
            totalDoses++;
            if (info.checked) takenDoses++;
           
            // 薬品別カウント
            medicationCount[info.medicine] = (medicationCount[info.medicine] ?? 0) + 1;
            if (info.checked) {
              medicationTakenCount[info.medicine] = (medicationTakenCount[info.medicine] ?? 0) + 1;
            }
          }
        }
      }
      
      // 服用メモのチェック状態を統計に反映（日付別）
      for (final entry in _weekdayMedicationStatus.entries) {
        final dateStr = entry.key;
        final dayStatus = entry.value;
        
        for (final memo in _medicationMemos) {
          if (dayStatus[memo.id] == true) {
            totalDoses++;
            takenDoses++;
            medicationCount[memo.name] = (medicationCount[memo.name] ?? 0) + 1;
            medicationTakenCount[memo.name] = (medicationTakenCount[memo.name] ?? 0) + 1;
          }
        }
      }
     
      // 統計サマリーを追加
      csvContent.writeln('');
      csvContent.writeln('=== 統計サマリー ===');
      csvContent.writeln('総服薬回数,$totalDoses');
      csvContent.writeln('服薬済み回数,$takenDoses');
      csvContent.writeln('全体遵守率,${totalDoses > 0 ? (takenDoses / totalDoses * 100).toStringAsFixed(1) : 0}%');
      csvContent.writeln('');
      csvContent.writeln('=== 薬品別統計 ===');
      csvContent.writeln('薬品名,総回数,服薬済み回数,遵守率');
     
      for (final medication in medicationCount.keys) {
        final total = medicationCount[medication]!;
        final taken = medicationTakenCount[medication] ?? 0;
        final rate = total > 0 ? (taken / total * 100) : 0;
        csvContent.writeln('$medication,$total,$taken,${rate.toStringAsFixed(1)}%');
      }
     
      await file.writeAsString(csvContent.toString());
     
      final xFile = XFile(file.path);
      await Share.shareXFiles([xFile], text: '服薬データをエクスポートしました（統計情報付き）');
     
      _showSnackBar('CSVファイルをエクスポートしました（統計情報付き）');
    } catch (e) {
      _showSnackBar('CSVエクスポートに失敗しました: $e');
    }
  }
 
  TimeOfDay _parseTimeString(String timeStr) {
    final parts = timeStr.split(':');
    return TimeOfDay(
      hour: int.parse(parts[0]),
      minute: int.parse(parts[1]),
    );
  }

  void _selectAllDates() {
    setState(() {
      _selectedDates.clear();
      final now = DateTime.now();
      final startDate = DateTime(now.year, now.month, 1);
      final endDate = DateTime(now.year, now.month + 1, 0);
      
      for (int i = 0; i <= endDate.difference(startDate).inDays; i++) {
        final date = startDate.add(Duration(days: i));
        _selectedDates.add(_normalizeDate(date));
      }
      
      if (_selectedDates.isNotEmpty) {
        _selectedDay = _selectedDates.first;
      }
    });
    _updateMedicineInputsForSelectedDate();
    _showSnackBar('今月のすべての日付を選択しました');
  }

  void _clearAllSelections() {
    setState(() {
      _selectedDates.clear();
      _selectedDay = null;
    });
    _updateMedicineInputsForSelectedDate();
    _showSnackBar('すべての選択を解除しました');
  }

  // 選択された日付の曜日に基づいて服用メモを取得
  List<MedicationMemo> _getMedicationsForSelectedDay() {
    if (_selectedDay == null) return [];
    
    final weekday = _selectedDay!.weekday % 7; // 0=日曜日, 1=月曜日, ..., 6=土曜日
    return _medicationMemos.where((memo) => memo.selectedWeekdays.contains(weekday)).toList();
  }

  // 曜日設定された薬の服用状況を取得
  bool _getWeekdayMedicationStatus(String memoId) {
    if (_selectedDay == null) return false;
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    return _weekdayMedicationStatus[dateStr]?[memoId] ?? false;
  }

  // 曜日設定された薬の服用状況を更新
  void _updateWeekdayMedicationStatus(String memoId, bool isTaken) {
    if (_selectedDay == null) return;
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    _weekdayMedicationStatus.putIfAbsent(dateStr, () => {});
    _weekdayMedicationStatus[dateStr]![memoId] = isTaken;
  }

  // 曜日設定された薬を表示するウィジェット
  Widget _buildWeekdayMedicationRecord(MedicationMemo memo) {
    final isChecked = _getWeekdayMedicationStatus(memo.id);
    
    return Container(
      margin: const EdgeInsets.only(bottom: 20), // 間隔を広く
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(16),
        border: isChecked
            ? Border.all(color: memo.color, width: 2)
            : Border.all(color: memo.color.withOpacity(0.3)),
        boxShadow: [
          BoxShadow(
            color: isChecked 
                ? memo.color.withOpacity(0.2)
                : memo.color.withOpacity(0.1),
            spreadRadius: 1,
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16),
          gradient: isChecked
              ? LinearGradient(
                  colors: [memo.color.withOpacity(0.1), memo.color.withOpacity(0.05)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                )
              : LinearGradient(
                  colors: [memo.color.withOpacity(0.05), memo.color.withOpacity(0.02)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
        ),
        child: Padding(
          padding: const EdgeInsets.all(24), // パディングを増加
          child: Row(
            children: [
              // 服用済みチェックボックス
              GestureDetector(
                onTap: () async {
                  // ✅ 変更前スナップショット（服用メモのチェック切替）
                  await _saveSnapshotBeforeChange('服用チェック_${memo.name}');
                  setState(() {
                    _updateWeekdayMedicationStatus(memo.id, !isChecked);
                  });
                  _saveCurrentDataDebounced();
                  _updateCalendarMarks();
                },
                child: Container(
                  width: 60, // サイズを大きく
                  height: 60,
                  decoration: BoxDecoration(
                    color: isChecked ? memo.color : memo.color.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                    boxShadow: isChecked
                        ? [
                            BoxShadow(
                              color: memo.color.withOpacity(0.3),
                              spreadRadius: 1,
                              blurRadius: 4,
                              offset: const Offset(0, 2),
                            ),
                          ]
                        : null,
                  ),
                  child: Icon(
                    isChecked ? Icons.check_circle : Icons.radio_button_unchecked,
                    color: isChecked ? Colors.white : memo.color,
                    size: 30,
                  ),
                ),
              ),
              const SizedBox(width: 24), // 間隔を広く
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          memo.type == 'サプリメント' ? Icons.eco : Icons.medication,
                          color: memo.color,
                          size: 20,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            memo.name,
                            style: const TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.black87,
                            ),
                          ),
                        ),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: memo.color.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(color: memo.color.withOpacity(0.3)),
                          ),
                          child: Text(
                            memo.type,
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.w500,
                              color: memo.color,
                            ),
                          ),
                        ),
                      ],
                    ),
                    if (memo.dosage.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        '用量: ${memo.dosage}',
                        style: const TextStyle(
                          fontSize: 14,
                          color: Colors.grey,
                        ),
                      ),
                    ],
                    if (memo.notes.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        memo.notes,
                        style: const TextStyle(
                          fontSize: 13,
                          color: Colors.grey,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }


  void _addMedicationToTimeSlot(String medicationName) {
    // ✅ 変更前スナップショット（非同期だが待たずに実行）
    _saveSnapshotBeforeChange('薬追加_$medicationName');
    // メモ制限チェック
    if (!_canAddMemo()) {
      _showLimitDialog('メモ');
      return;
    }
    
    // 服用メモから薬の詳細情報を取得
    final memo = _medicationMemos.firstWhere(
      (memo) => memo.name == medicationName,
      orElse: () {
        // 空タイトルへの対応: 自動連番を割り当て
        final titles = _medicationMemos.map((m) => m.name).toList();
        final autoTitle = _generateDefaultTitle(titles);
        return MedicationMemo(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
          name: medicationName.trim().isEmpty ? autoTitle : medicationName,
        type: '薬',
        color: Colors.blue,
        dosage: '',
        notes: '',
        createdAt: DateTime.now(),
        );
      },
    );
    
    // 新しい薬をリストに追加
    setState(() {
      _addedMedications.add({
        'name': memo.name,
        'type': memo.type,
        'color': memo.color,
        'dosage': memo.dosage,
        'notes': memo.notes,
        'isChecked': false,
      });
    });
    
    _saveCurrentDataDebounced();
    _showSnackBar('$medicationName を服用記録に追加しました');
  }

  // 完全に作り直されたカレンダーマーク更新
  void _updateCalendarMarks() {
    if (_selectedDay == null) return;
    
    // 強制的にカレンダーを更新
    setState(() {
      // カレンダーのマークを強制更新
    });
  }

  // 軽量化された統計計算メソッド
  Map<String, int> _calculateMedicationStats() {
    if (_selectedDay == null) return {'total': 0, 'taken': 0};
    
    int totalMedications = 0;
    int takenMedications = 0;
    
    // 動的薬リストの統計
    totalMedications += _addedMedications.length;
    takenMedications += _addedMedications.where((med) => med['isChecked'] == true).length;
    
    // 服用メモの統計（軽量化）
    final weekday = _selectedDay!.weekday % 7;
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    
    for (final memo in _medicationMemos) {
      if (memo.selectedWeekdays.isNotEmpty && memo.selectedWeekdays.contains(weekday)) {
        totalMedications++;
        if (_medicationMemoStatus[memo.id] == true) {
          takenMedications++;
        }
      }
    }
    
    return {'total': totalMedications, 'taken': takenMedications};
  }

  Widget _buildMedicationStats() {
    if (_selectedDay == null) return const SizedBox.shrink();
    
    // 完全に作り直された統計計算
    int totalMedications = 0;
    int takenMedications = 0;
    
    // 動的薬リストの統計
    totalMedications += _addedMedications.length;
    takenMedications += _addedMedications.where((med) => med['isChecked'] == true).length;
    
    // 服用メモの統計（今日の曜日に該当するもののみ）
    final weekday = _selectedDay!.weekday % 7;
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
    
    for (final memo in _medicationMemos) {
      if (memo.selectedWeekdays.isNotEmpty && memo.selectedWeekdays.contains(weekday)) {
        totalMedications++;
        if (_medicationMemoStatus[memo.id] == true) {
          takenMedications++;
        }
      }
    }
    
    final progress = totalMedications > 0 ? takenMedications / totalMedications : 0.0;
    
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: progress == 1.0 
            ? [Colors.green.withOpacity(0.1), Colors.green.withOpacity(0.05)]
            : [Colors.orange.withOpacity(0.1), Colors.orange.withOpacity(0.05)],
        ),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: progress == 1.0 ? Colors.green : Colors.orange,
          width: 2,
        ),
      ),
      child: Row(
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(
                      progress == 1.0 ? Icons.check_circle : Icons.schedule,
                      color: progress == 1.0 ? Colors.green : Colors.orange,
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      '今日の服用状況',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: progress == 1.0 ? Colors.green : Colors.orange,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  '$takenMedications / $totalMedications 服用済み',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: progress == 1.0 ? Colors.green : Colors.orange,
                  ),
                ),
                if (totalMedications > 0) ...[
                  const SizedBox(height: 4),
                  LinearProgressIndicator(
                    value: progress,
                    backgroundColor: Colors.grey.withOpacity(0.3),
                    valueColor: AlwaysStoppedAnimation<Color>(
                      progress == 1.0 ? Colors.green : Colors.orange,
                    ),
                  ),
                ],
              ],
            ),
          ),
          const SizedBox(width: 16),
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: progress == 1.0 ? Colors.green : Colors.orange,
              boxShadow: [
                BoxShadow(
                  color: (progress == 1.0 ? Colors.green : Colors.orange).withOpacity(0.3),
                  spreadRadius: 2,
                  blurRadius: 8,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Center(
              child: Text(
                '${(progress * 100).toInt()}%',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMemoField() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // ✅ 修正：オーバーフローを防ぐためにFlexibleを使用
        Row(
          children: [
            Icon(Icons.note_alt, color: Colors.blue, size: 16),
            const SizedBox(width: 6),
            Flexible(
              child: Text(
              '今日のメモ',
              style: TextStyle(
                fontSize: 14, // フォントサイズ削減
                fontWeight: FontWeight.bold,
                color: Colors.grey,
                ),
                overflow: TextOverflow.ellipsis, // テキストオーバーフロー対策
              ),
            ),
            const Spacer(),
            if (_memoController.text.isNotEmpty)
              Flexible(
                child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2), // パディング削減
                decoration: BoxDecoration(
                  color: Colors.green.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8), // 角丸削減
                  border: Border.all(color: Colors.green.withOpacity(0.3)),
                ),
                child: const Text(
                  '保存済み',
                  style: TextStyle(
                    fontSize: 10, // フォントサイズ削減
                    color: Colors.green,
                    fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ),
          ],
        ),
        const SizedBox(height: 6), // 間隔削減
        Container(
          width: double.infinity,
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(8), // 角丸削減
            border: Border.all(
              color: _isMemoFocused ? Colors.blue.withOpacity(0.5) : Colors.grey.withOpacity(0.3),
              width: _isMemoFocused ? 1.5 : 1,
            ),
            boxShadow: _isMemoFocused ? [
              BoxShadow(
                color: Colors.blue.withOpacity(0.1),
                spreadRadius: 1,
                blurRadius: 2,
                offset: const Offset(0, 1),
              ),
            ] : null,
          ),
          child: ValueListenableBuilder<String>(
            valueListenable: _memoTextNotifier,
            builder: (context, memoText, _) {
              _memoController.value = _memoController.value.copyWith(text: memoText, selection: TextSelection.collapsed(offset: memoText.length));
              return TextField(
            controller: _memoController,
            focusNode: _memoFocusNode,
            maxLines: 2, // 2行表示に固定
            minLines: 2, // 最小行数を2に変更
            decoration: InputDecoration(
              hintText: '副作用、病院、通院記録など',
              hintStyle: const TextStyle(
                color: Colors.grey,
                fontSize: 12, // フォントサイズ削減
              ),
              border: InputBorder.none,
              contentPadding: const EdgeInsets.all(12), // パディング削減
              suffixIcon: (_memoController.text.isNotEmpty)
                  ? IconButton(
                      onPressed: () async {
                        // ✅ 変更前スナップショット（メモクリア）
                        if (_selectedDay != null) {
                          await _saveSnapshotBeforeChange('メモクリア_${DateFormat('yyyy-MM-dd').format(_selectedDay!)}');
                        }
                        _memoTextNotifier.value = '';
                        _saveMemo();
                      },
                      icon: const Icon(Icons.clear, color: Colors.grey, size: 16),
                    )
                  : null,
            ),
            style: TextStyle(
              fontSize: 14,
              color: Theme.of(context).brightness == Brightness.dark 
                  ? Colors.lightGreen[300] 
                  : Colors.black87,
            ),
            onTap: () async {
              // トライアル制限チェック
              final isExpired = await TrialService.isTrialExpired();
              if (isExpired) {
                showDialog(
                  context: context,
                  builder: (context) => TrialLimitDialog(featureName: 'メモ'),
                );
                FocusScope.of(context).unfocus();
                return;
              }
              setState(() {
                _isMemoFocused = true;
              });
            },
            onChanged: (value) {
              // デバウンス処理でスナップショット保存を制限
              _debounce?.cancel();
              _debounce = Timer(const Duration(milliseconds: 500), () async {
                // デバウンス後にスナップショット保存（1回だけ）
                if (_selectedDay != null && !_memoSnapshotSaved) {
                await _saveSnapshotBeforeChange('メモ変更_${DateFormat('yyyy-MM-dd').format(_selectedDay!)}');
                  _memoSnapshotSaved = true;
              }
                _memoTextNotifier.value = value;
                _saveMemo();
              });
              // 即座にUIを更新
              _memoTextNotifier.value = value;
            },
            onSubmitted: (value) {
              // キーボードの決定ボタンで完了
              _completeMemo();
            },
            onEditingComplete: () {
              _completeMemo();
            },
              );
            },
          ),
        ),
        // メモ入力時の完了ボタン（コンパクト化）
        if (_isMemoFocused) ...[
          const SizedBox(height: 8), // 間隔削減
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              ElevatedButton.icon(
                onPressed: () {
                  _completeMemo();
                },
                icon: const Icon(Icons.save, size: 16), // アイコンサイズ削減
                label: const Text('保存', style: TextStyle(fontSize: 12)), // フォントサイズ削減
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8), // パディング削減
                  minimumSize: const Size(0, 32), // 最小サイズ設定
                ),
              ),
              ElevatedButton.icon(
                onPressed: () async {
                  // ✅ 変更前スナップショット（メモクリア）
                  if (_selectedDay != null) {
                    await _saveSnapshotBeforeChange('メモクリア_${DateFormat('yyyy-MM-dd').format(_selectedDay!)}');
                  }
                  setState(() {
                    _memoController.clear();
                    _isMemoFocused = false;
                  });
                  _saveMemo();
                  FocusScope.of(context).unfocus();
                },
                icon: const Icon(Icons.clear, size: 16), // アイコンサイズ削減
                label: const Text('クリア', style: TextStyle(fontSize: 12)), // フォントサイズ削減
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8), // パディング削減
                  minimumSize: const Size(0, 32), // 最小サイズ設定
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }

  Future<void> _saveMemo() async {
    try {
      if (_selectedDay != null) {
        final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString('memo_$dateStr', _memoController.text);
      }
    } catch (e) {
    }
  }
  
  void _completeMemo() {
    setState(() {
      _isMemoFocused = false;
      _memoSnapshotSaved = false; // スナップショット保存フラグをリセット
    });
    // カーソルの選択を外す
    FocusScope.of(context).unfocus();
    _saveMemo().then((_) {
      if (_memoController.text.isNotEmpty) {
        _showSnackBar('メモを保存しました');
      } else {
        _showSnackBar('メモをクリアしました');
      }
    });
  }

  // トライアル状態表示ダイアログ
  Future<void> _showTrialStatus() async {
    final status = await TrialService.getPurchaseStatus();
    final remainingMinutes = await TrialService.getRemainingMinutes();
    
    if (!mounted) return;
    
    // 状態に応じたアイコンと色を設定
    IconData statusIcon;
    Color statusColor;
    String statusText;
    
    switch (status) {
      case TrialService.trialStatus:
        statusIcon = Icons.timer;
        statusColor = Colors.blue;
        statusText = 'トライアル中';
        break;
      case TrialService.expiredStatus:
        statusIcon = Icons.warning;
        statusColor = Colors.red;
        statusText = '期限切れ';
        break;
      case TrialService.purchasedStatus:
        statusIcon = Icons.check_circle;
        statusColor = Colors.green;
        statusText = '購入済み';
        break;
      default:
        statusIcon = Icons.timer;
        statusColor = Colors.blue;
        statusText = 'トライアル中';
    }
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: Row(
          children: [
            Icon(statusIcon, color: statusColor),
            const SizedBox(width: 12),
            const Text('購入状態'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildStatusRow('現在の状態', statusText, statusColor),
            if (status == TrialService.trialStatus) ...[
            const SizedBox(height: 12),
            _buildStatusRow('残り時間', 
                  '${(remainingMinutes / (24 * 60)).ceil()}日',
                  Colors.orange),
            ],
            if (status == TrialService.expiredStatus) ...[
              const SizedBox(height: 12),
              _buildStatusRow('期限', '7日間終了', Colors.red),
            ],
            if (status == TrialService.purchasedStatus) ...[
              const SizedBox(height: 12),
              _buildStatusRow('有効期限', '無制限', Colors.green),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('閉じる'),
          ),
          if (status == TrialService.expiredStatus)
            ElevatedButton(
              onPressed: () async {
                Navigator.of(context).pop();
                await _showPurchaseLinkDialog();
              },
              child: const Text('購入する'),
          ),
        ],
      ),
    );
  }
  
  Widget _buildStatusRow(String label, String value, Color color) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: const TextStyle(
            fontSize: 15,
            fontWeight: FontWeight.w500,
          ),
        ),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          decoration: BoxDecoration(
            color: color.withOpacity(0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: color.withOpacity(0.3)),
          ),
          child: Text(
            value,
            style: TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ),
      ],
    );
  }
  
  // 警告ダイアログを表示するメソッド
  void _showWarningDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: Row(
          children: [
            const Icon(Icons.warning, color: Colors.orange),
            const SizedBox(width: 12),
            const Text('注意'),
          ],
        ),
        content: const Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
            Text(
              '服用回数が多いため、',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: Colors.orange,
              ),
            ),
            Text(
              '医師の指示に従ってください',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: Colors.orange,
                          ),
                        ),
                      ],
                    ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('了解'),
          ),
        ],
      ),
    );
    
    // 3秒後に自動で閉じる
    Future.delayed(const Duration(seconds: 3), () {
      if (Navigator.of(context).canPop()) {
        Navigator.of(context).pop();
      }
    });
  }
  
  // 購入状態に設定するメソッド
  Future<void> _setPurchasedStatus() async {
    if (!mounted) return;
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: const Row(
          children: [
            Icon(Icons.check_circle, color: Colors.green),
            SizedBox(width: 12),
            Text('購入状態に設定'),
          ],
        ),
        content: const Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
            Text(
              'アプリを購入済み状態に設定しますか？',
              style: TextStyle(fontSize: 16),
            ),
            SizedBox(height: 16),
            Text(
              '設定後は以下の機能が無制限で使用できます：',
                        style: TextStyle(
                          fontSize: 14,
                          fontWeight: FontWeight.w500,
              ),
            ),
            SizedBox(height: 8),
            Text('• メモの追加・編集'),
            Text('• アラーム機能'),
            Text('• 統計機能'),
            Text('• カレンダー機能'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('キャンセル'),
          ),
          ElevatedButton(
            onPressed: () async {
              await TrialService.setPurchaseStatus(TrialService.purchasedStatus);
              Navigator.of(context).pop();
              
              // 実際の購入時と同じメッセージを表示
              showDialog(
                context: context,
                barrierDismissible: false,
                builder: (context) => AlertDialog(
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16),
                  ),
                  title: const Row(
                    children: [
                      Icon(Icons.check_circle, color: Colors.green, size: 32),
                      SizedBox(width: 12),
                      Text('購入完了！'),
                    ],
                  ),
                  content: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Text(
                        '商品購入後、期限が無期限になりました！',
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: Colors.green,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.green.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.green.withOpacity(0.3)),
                ),
                        child: const Column(
                  children: [
                            Text(
                              '🎉 プレミアム機能が有効になりました！',
                      style: TextStyle(
                            fontSize: 16,
                        fontWeight: FontWeight.bold,
                          ),
                          textAlign: TextAlign.center,
                        ),
                            SizedBox(height: 8),
                            Text(
                              '• メモの追加・編集\n• アラーム機能\n• 統計機能\n• カレンダー機能',
                              style: TextStyle(fontSize: 14),
                              textAlign: TextAlign.left,
                        ),
                      ],
                    ),
                      ),
                    ],
                  ),
                  actions: [
                    ElevatedButton(
                      onPressed: () => Navigator.of(context).pop(),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.green,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 12),
                      ),
                      child: const Text('ありがとうございます！'),
                    ),
                  ],
                ),
              );
            },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.green,
                        foregroundColor: Colors.white,
            ),
            child: const Text('購入済みに設定'),
          ),
        ],
      ),
    );
  }

  // トライアル状態に設定
  Future<void> _setTrialStatus() async {
    if (!mounted) return;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.timer, color: Colors.blue),
            SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text('トライアル状態に'),
                  Text('設定'),
                  ],
                ),
              ),
          ],
        ),
        content: const Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'アプリをトライアル状態に設定しますか？',
              style: TextStyle(fontSize: 16),
            ),
            SizedBox(height: 16),
            Text(
              '設定後は以下の制限が適用されます：',
                        style: TextStyle(
                          fontSize: 14,
                          fontWeight: FontWeight.w500,
              ),
            ),
            SizedBox(height: 8),
            Text('• トライアル期間: 7日間'),
            Text('• 期限切れ後は機能制限'),
            Text('• 購入で制限解除'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('キャンセル'),
          ),
          ElevatedButton(
            onPressed: () async {
              // トライアルをリセットして新しいトライアルを開始
              await TrialService.resetTrial();
              await TrialService.initializeTrial();
              await TrialService.setPurchaseStatus(TrialService.trialStatus);
              Navigator.of(context).pop();
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('トライアル状態に設定しました（7日間）'),
                  backgroundColor: Colors.blue,
                ),
              );
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blue,
              foregroundColor: Colors.white,
            ),
            child: const Text('トライアルに設定'),
          ),
        ],
      ),
    );
  }



  // アプリ内課金ダイアログを表示
  Future<void> _showPurchaseLinkDialog() async {
    if (!mounted) return;
    
    // 商品情報を取得
    final ProductDetails? product = await InAppPurchaseService.getProductDetails();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: const Row(
          children: [
            Icon(Icons.payment, color: Colors.green),
            SizedBox(width: 12),
            Text('アプリ内課金'),
          ],
        ),
        content: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 商品情報表示
              if (product != null) ...[
              Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: Colors.blue.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
                          const Icon(Icons.shopping_bag, color: Colors.blue, size: 20),
              const SizedBox(width: 8),
              const Text(
                            'プレミアム機能',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                              color: Colors.blue,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
                      Text(
                        '商品名: ${product.title}',
                        style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        '説明: ${product.description}',
                        style: const TextStyle(fontSize: 12),
                    ),
                    const SizedBox(height: 8),
                      Text(
                        '価格: ${product.price}',
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: Colors.green,
                        ),
          ),
        ],
      ),
                ),
                const SizedBox(height: 16),
              ],
              
              // 機能説明
                    Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
                  color: Colors.orange.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.orange.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
                        const Icon(Icons.info, color: Colors.orange, size: 20),
              const SizedBox(width: 8),
          const Text(
                          'プレミアム機能',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                            color: Colors.orange,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          const Text(
                      '購入後は以下の機能が無制限で使用できます：',
            style: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
          ),
                    const SizedBox(height: 8),
                    const Text('• メモの追加・編集'),
                    const Text('• アラーム機能'),
                    const Text('• 統計機能'),
                    const Text('• カレンダー機能'),
                  ],
                ),
              ),
              const SizedBox(height: 20),
              
              // 購入ボタン
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.green.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.green.withOpacity(0.3)),
                ),
                child: Column(
                  children: [
                    const Text(
                      'アプリ内課金で購入',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Colors.green,
                      ),
          ),
          const SizedBox(height: 12),
          ElevatedButton.icon(
                      onPressed: product != null ? () async {
                        Navigator.of(context).pop();
                        await _startPurchase(product);
                      } : null,
                      icon: const Icon(Icons.shopping_cart),
                      label: Text(product != null ? '${product.price}で購入' : '商品情報を取得中...'),
            style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.green,
              foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                        textStyle: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    const SizedBox(height: 8),
                    TextButton(
                      onPressed: () async {
                        Navigator.of(context).pop();
                        await InAppPurchaseService.restorePurchases();
                        
                        // 購入履歴復元の結果を確認
                        final isPurchased = await InAppPurchaseService.isPurchased();
                        if (isPurchased) {
                          // 購入履歴が復元された場合の特別なメッセージ
    showDialog(
      context: context,
                            barrierDismissible: false,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: const Row(
          children: [
                                  Icon(Icons.restore, color: Colors.blue, size: 32),
            SizedBox(width: 12),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment: CrossAxisAlignment.start,
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        Text('購入履歴復元'),
                                        Text('完了！'),
                  ],
                ),
              ),
                                ],
                              ),
                              content: const Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
                                    '商品購入後、期限が無期限になりました！',
              style: TextStyle(
                                      fontSize: 18,
                fontWeight: FontWeight.bold,
                                      color: Colors.green,
                                    ),
                                    textAlign: TextAlign.center,
                                  ),
                                  SizedBox(height: 16),
                                  Text(
                                    '過去の購入履歴が復元され、プレミアム機能が有効になりました。',
                                    style: TextStyle(fontSize: 14),
                                    textAlign: TextAlign.center,
                                  ),
                                ],
                              ),
                              actions: [
                                ElevatedButton(
                                  onPressed: () => Navigator.of(context).pop(),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.blue,
                                    foregroundColor: Colors.white,
                                  ),
                                  child: const Text('ありがとうございます！'),
                                ),
                              ],
                            ),
                          );
                        } else {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text('購入履歴が見つかりませんでした')),
                          );
                        }
                      },
                      child: const Text('購入履歴を復元'),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('閉じる'),
          ),
        ],
      ),
    );
  }



  // 購入を開始
  Future<void> _startPurchase(ProductDetails product) async {
    // 購入結果の監視を開始
    InAppPurchaseService.startPurchaseListener((success, error) {
      if (success) {
        // 購入成功時の特別なメッセージを表示
    showDialog(
      context: context,
          barrierDismissible: false,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: const Row(
          children: [
                Icon(Icons.check_circle, color: Colors.green, size: 32),
            SizedBox(width: 12),
                Text('購入完了！'),
          ],
        ),
            content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
                const Text(
                  '商品購入後、期限が無期限になりました！',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.green,
                  ),
                  textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: Colors.green.withOpacity(0.3)),
                  ),
                  child: const Column(
                    children: [
            Text(
                        '🎉 プレミアム機能が有効になりました！',
              style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      SizedBox(height: 8),
                      Text(
                        '• メモの追加・編集\n• アラーム機能\n• 統計機能\n• カレンダー機能',
                        style: TextStyle(fontSize: 14),
                        textAlign: TextAlign.left,
                      ),
                    ],
              ),
            ),
          ],
        ),
        actions: [
              ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 12),
                ),
                child: const Text('ありがとうございます！'),
          ),
        ],
      ),
    );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('購入に失敗しました: ${error ?? "不明なエラー"}'),
            backgroundColor: Colors.red,
      ),
    );
  }
    });
    
    // 購入を開始
    final success = await InAppPurchaseService.purchaseProduct();
    if (!success) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('購入の開始に失敗しました'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  // ✅ バックアップ機能を実装
  Future<void> _showBackupDialog() async {
    if (!mounted) return;
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.backup, color: Colors.orange),
            SizedBox(width: 8),
            Text('バックアップ'),
          ],
        ),
        content: SizedBox(
          width: double.maxFinite,
          child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.blue.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Text(
                  '⏱ バックアップ間隔\n\n'
                  '・毎日深夜2:00（自動）- フルバックアップ\n'
                  '・操作後5分以内（自動）- 差分バックアップ\n'
                  '・手動保存（任意）- 任意タイミングで保存',
                  style: TextStyle(fontSize: 14),
                ),
              ),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                onPressed: () async {
                  Navigator.of(context).pop();
                  await _createManualBackup();
                },
                icon: const Icon(Icons.save),
                label: const Text('手動バックアップを作成'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                  ),
                ),
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                onPressed: () async {
                  Navigator.of(context).pop();
                  await _showBackupHistory();
                },
                icon: const Icon(Icons.history),
                label: const Text('保存履歴を見る'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  ),
                ),
              ),
              const SizedBox(height: 8),
              FutureBuilder<bool>(
                future: _hasUndoAvailable(),
                builder: (context, snapshot) {
                  final available = snapshot.data ?? false;
                  return SizedBox(
                    width: double.infinity,
                    child: ElevatedButton.icon(
                      onPressed: available
                          ? () async {
                              Navigator.of(context).pop();
                              await _undoLastChange();
                            }
                          : null,
                      icon: const Icon(Icons.undo),
                      label: const Text('1つ前の状態に復元'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: available ? Colors.teal : Colors.grey,
                        foregroundColor: Colors.white,
                      ),
                    ),
                  );
                },
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: () async {
                    Navigator.of(context).pop();
                    final prefs = await SharedPreferences.getInstance();
                    // ✅ 最新フルバックアップを参照
                    final key = prefs.getString('last_full_backup_key');
                    if (key != null) {
                      await _restoreBackup(key);
                    } else {
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('フルバックアップが見つかりません'),
                            backgroundColor: Colors.red,
                          ),
                        );
                      }
                    }
                  },
                  icon: const Icon(Icons.restore_page),
                  label: const Text('フルバックアップを復元（最新）'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.purple,
                    foregroundColor: Colors.white,
                  ),
                ),
              ),
            ],
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('閉じる'),
          ),
        ],
      ),
    );
  }

  // ✅ 直前の変更が存在するか（スナップショット有無）
  Future<bool> _hasUndoAvailable() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastKey = prefs.getString('last_snapshot_key');
      if (lastKey == null) {
        debugPrint('⚠️ last_snapshot_key が null');
        return false;
      }
      final data = prefs.getString(lastKey);
      final available = data != null;
      if (!available) {
        debugPrint('⚠️ スナップショット実体が見つかりません: $lastKey');
      }
      return available;
    } catch (e) {
      debugPrint('❌ スナップショット確認エラー: $e');
      return false;
    }
  }

  // ✅ 変更前スナップショット保存
  Future<void> _saveSnapshotBeforeChange(String operationType) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final snapshotData = await _createSafeBackupData('変更前_$operationType');
      final jsonString = await _safeJsonEncode(snapshotData);
      final encryptedData = await _encryptDataAsync(jsonString);
      final snapshotKey = 'snapshot_before_$timestamp';
      final ok1 = await prefs.setString(snapshotKey, encryptedData);
      final ok2 = await prefs.setString('last_snapshot_key', snapshotKey);
      if (!(ok1 && ok2)) {
        debugPrint('⚠️ スナップショット保存フラグがfalse: $ok1, $ok2');
      }
      debugPrint('✅ 変更前スナップショット保存完了: $operationType (key: $snapshotKey)');
    } catch (e) {
      debugPrint('❌ スナップショット保存エラー: $e');
    }
  }

  // ✅ 1つ前の状態に復元（最新スナップショットから）
  Future<void> _undoLastChange() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final lastSnapshotKey = prefs.getString('last_snapshot_key');
      if (lastSnapshotKey == null) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('復元できる履歴がありません'),
              backgroundColor: Colors.orange,
            ),
          );
        }
        return;
      }

      await _restoreBackup(lastSnapshotKey);
      // 復元に使用したスナップショットは削除（1回使い切り）
      await prefs.remove(lastSnapshotKey);
      await prefs.remove('last_snapshot_key');
      if (mounted) {
        setState(() {
          _focusedDay = _selectedDay ?? DateTime.now();
          // ✅ 追加：メモフィールドを再同期
          if (_selectedDay != null) {
            final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDay!);
            // 直近の保存内容を反映
            SharedPreferences.getInstance().then((p) {
              final memo = p.getString('memo_$dateStr');
              _memoController.text = memo ?? '';
              _memoTextNotifier.value = memo ?? '';
            });
          }
          // ✅ 追加：アラームタブの完全再構築
          _alarmTabKey = UniqueKey();
          // ✅ 追加：カレンダー色の再同期
          _dayColorsNotifier.value = Map<String, Color>.from(_dayColors);
        });
        // ✅ 追加：カレンダーと入力を再評価
        await _updateMedicineInputsForSelectedDate();
        await _loadMemoForSelectedDate();
        // ✅ 追加：統計の再計算
        await _calculateAdherenceStats();
        // ✅ 追加：服用記録の表示を強制更新
        _updateCalendarMarks();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('✓ 1つ前の状態に復元しました'),
            backgroundColor: Colors.blue,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      debugPrint('❌ 復元エラー: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('復元に失敗しました: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Widget _buildBackupRecommendation(String timing, String content, String reason, Color color) {
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(6),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(timing, style: TextStyle(fontSize: 14, fontWeight: FontWeight.bold, color: color)),
          Text(content, style: const TextStyle(fontSize: 12)),
          Text(reason, style: TextStyle(fontSize: 11, color: Colors.grey[600])),
        ],
      ),
    );
  }

  // ✅ 手動バックアップ作成機能
  Future<void> _createManualBackup() async {
    if (!mounted) return;
    
    // 保存名入力ダイアログ
    final TextEditingController nameController = TextEditingController();
    final now = DateTime.now();
    nameController.text = '${DateFormat('yyyy-MM-dd_HH-mm').format(now)}_手動保存';
    
    final result = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('バックアップ名を入力'),
        content: TextField(
          controller: nameController,
          decoration: const InputDecoration(
            hintText: '例: 2024-01-15_14-30_手動保存',
            border: OutlineInputBorder(),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('キャンセル'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(nameController.text),
            child: const Text('保存'),
          ),
        ],
      ),
    );
    
    if (result != null && result.isNotEmpty) {
      await _performBackup(result);
    }
  }

  // ✅ 統合されたバックアップ作成メソッド（1回で完了）
  Future<void> _performBackup(String backupName) async {
    if (!mounted) return;
    
    // ローディング表示
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              SizedBox(
                width: 16,
                height: 16,
              child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
              ),
              SizedBox(width: 8),
              Text('バックアップを作成中...'),
            ],
          ),
        duration: Duration(seconds: 1),
      ),
    );
    
    try {
      final prefs = await SharedPreferences.getInstance();
      final backupKey = 'backup_${DateTime.now().millisecondsSinceEpoch}';
      
      // 1. バックアップデータを直接作成（型安全な変換）
      final backupData = await _createSafeBackupData(backupName);
      
      // 2. JSONエンコード（エラーハンドリング付き）
      final jsonString = await _safeJsonEncode(backupData);
      
      // 3. 暗号化（非同期）
      final encryptedData = await _encryptDataAsync(jsonString);
      
      // 4. 保存（1回で完了）
      await prefs.setString(backupKey, encryptedData);
      
      // 5. 履歴更新
      await _updateBackupHistory(backupName, backupKey);
      
      if (!mounted) return;
      
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
          content: Text('✓ バックアップ「$backupName」を作成しました'),
            backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
          ),
        );
    } catch (e) {
      debugPrint('バックアップ作成エラー: $e');
      if (!mounted) return;
      
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
          content: Text('バックアップの作成に失敗しました: ${e.toString()}'),
            backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  // ✅ 型安全なバックアップデータ作成
  Future<Map<String, dynamic>> _createSafeBackupData(String backupName) async {
      return {
        'name': backupName,
        'createdAt': DateTime.now().toIso8601String(),
        'type': 'manual',
      'version': '1.0.0', // バージョン情報を追加
      
      // 服用メモ関連（JSON安全）
        'medicationMemos': _medicationMemos.map((memo) => memo.toJson()).toList(),
      'addedMedications': _addedMedications.map((med) => {
        'id': med['id'],
        'name': med['name'],
        'type': med['type'],
        'dosage': med['dosage'],
        'color': (med['color'] as Color).value, // Color → int
        'notes': med['notes'],
        'isChecked': med['isChecked'] ?? false,
        'takenTime': med['takenTime']?.toIso8601String(),
      }).toList(),
      
      // 薬品データ（JSON安全）
        'medicines': _medicines.map((medicine) => medicine.toJson()).toList(),
      
      // 服用データ（MedicationInfo → JSON）
        'medicationData': _medicationData.map((dateKey, dayData) {
        return MapEntry(
          dateKey,
          dayData.map((medKey, medInfo) {
            return MapEntry(medKey, medInfo.toJson());
          }),
        );
      }),
      
      // チェック状態関連（プリミティブ型のみ）
        'weekdayMedicationStatus': _weekdayMedicationStatus,
      'weekdayMedicationDoseStatus': _weekdayMedicationDoseStatus.map((dateKey, memoStatus) {
        return MapEntry(
          dateKey,
          memoStatus.map((memoId, doseStatus) {
            return MapEntry(
              memoId,
              doseStatus.map((doseIndex, isChecked) {
                return MapEntry(doseIndex.toString(), isChecked);
              }),
            );
          }),
        );
      }),
        'medicationMemoStatus': _medicationMemoStatus,
      
      // カレンダー色（Color → int）
        'dayColors': _dayColors.map((key, value) => MapEntry(key, value.value)),
      
      // アラーム関連（必要な全フィールドを保存）
      'alarmList': _alarmList.map((alarm) => {
        'name': alarm['name']?.toString(),
        'time': alarm['time']?.toString(),
        'repeat': alarm['repeat']?.toString(),
        'enabled': (alarm['enabled'] as bool?) ?? true,
        'alarmType': alarm['alarmType']?.toString(),
        'volume': (alarm['volume'] is int)
            ? alarm['volume'] as int
            : int.tryParse(alarm['volume']?.toString() ?? '80') ?? 80,
        'message': alarm['message']?.toString(),
        'isRepeatEnabled': (alarm['isRepeatEnabled'] as bool?) ?? false,
        'selectedDays': (alarm['selectedDays'] is List)
            ? List<bool>.from((alarm['selectedDays'] as List).map((e) => e == true))
            : [false, false, false, false, false, false, false],
      }).toList(),
      'alarmSettings': Map<String, dynamic>.from(_alarmSettings),
      
      // 統計データ
        'adherenceRates': _adherenceRates,
      };
  }

  // ✅ 安全なJSONエンコード（エラーハンドリング）
  Future<String> _safeJsonEncode(Map<String, dynamic> data) async {
    try {
      return jsonEncode(data);
      } catch (e) {
        debugPrint('JSONエンコードエラー: $e');
      debugPrint('問題のあるデータ: ${data.keys}');
      
      // エラーが発生した場合、問題のあるフィールドを特定
    final safeData = <String, dynamic>{};
      for (final entry in data.entries) {
      try {
          jsonEncode({entry.key: entry.value}); // 個別にテスト
        safeData[entry.key] = entry.value;
        } catch (fieldError) {
          debugPrint('フィールド ${entry.key} でエラー: $fieldError');
          safeData[entry.key] = null; // 問題のあるフィールドはnullに
        }
      }
      
      return jsonEncode(safeData);
    }
  }

  // ✅ 非同期暗号化
  Future<String> _encryptDataAsync(String data) async {
    // XOR暗号化
      final key = 'medication_app_backup_key_2024';
      final encrypted = StringBuffer();
      for (int i = 0; i < data.length; i++) {
        encrypted.write(String.fromCharCode(
          data.codeUnitAt(i) ^ key.codeUnitAt(i % key.length)
        ));
      }
      return encrypted.toString();
  }

  // ✅ 非同期復号化
  Future<String> _decryptDataAsync(String encryptedData) async {
    // XOR暗号化の復号化
    final key = 'medication_app_backup_key_2024';
    final decrypted = StringBuffer();
    for (int i = 0; i < encryptedData.length; i++) {
      decrypted.write(String.fromCharCode(
        encryptedData.codeUnitAt(i) ^ key.codeUnitAt(i % key.length)
      ));
    }
    return decrypted.toString();
  }

  // ✅ データ復号化機能
  String _decryptData(String encryptedData) {
    // XOR暗号化の復号化
    final key = 'medication_app_backup_key_2024';
    final decrypted = StringBuffer();
    for (int i = 0; i < encryptedData.length; i++) {
      decrypted.write(String.fromCharCode(
        encryptedData.codeUnitAt(i) ^ key.codeUnitAt(i % key.length)
      ));
    }
    return decrypted.toString();
  }

  // ✅ 非同期データ復元（最適化版）
  Future<void> _restoreDataAsync(Map<String, dynamic> backupData) async {
    try {
      // バージョンチェック
      final version = backupData['version'] as String?;
      if (version == null) {
        debugPrint('警告: バックアップバージョン情報がありません');
      }
      
      // 1. 服用メモの復元
      final restoredMemos = (backupData['medicationMemos'] as List? ?? [])
          .map((json) => MedicationMemo.fromJson(json as Map<String, dynamic>))
          .toList();
      
      // 2. 追加薬品の復元（Color変換）
      final restoredAddedMedications = (backupData['addedMedications'] as List? ?? [])
          .map((med) => {
            'id': med['id'],
            'name': med['name'],
            'type': med['type'],
            'dosage': med['dosage'],
            'color': Color(med['color'] as int), // int → Color
            'notes': med['notes'],
            'isChecked': med['isChecked'] ?? false,
            'takenTime': med['takenTime'] != null 
                ? DateTime.parse(med['takenTime'] as String)
                : null,
          })
          .cast<Map<String, dynamic>>()
          .toList();
      
      // 3. 薬品データの復元
      final restoredMedicines = (backupData['medicines'] as List? ?? [])
          .map((json) => MedicineData.fromJson(json as Map<String, dynamic>))
          .toList();
      
      // 4. 服用データの復元（JSON → MedicationInfo）
      final restoredMedicationData = <String, Map<String, MedicationInfo>>{};
      if (backupData['medicationData'] != null) {
        final medicationDataMap = backupData['medicationData'] as Map<String, dynamic>;
        for (final entry in medicationDataMap.entries) {
          final dateKey = entry.key;
          final dayData = entry.value as Map<String, dynamic>;
          final medicationInfoMap = <String, MedicationInfo>{};
          
          for (final medEntry in dayData.entries) {
            final medKey = medEntry.key;
            final medData = medEntry.value as Map<String, dynamic>;
            medicationInfoMap[medKey] = MedicationInfo.fromJson(medData);
          }
          
          restoredMedicationData[dateKey] = medicationInfoMap;
        }
      }
      
      // 5. チェック状態の復元
      final restoredWeekdayStatus = <String, Map<String, bool>>{};
      if (backupData['weekdayMedicationStatus'] != null) {
        final statusMap = backupData['weekdayMedicationStatus'] as Map<String, dynamic>;
        for (final entry in statusMap.entries) {
          restoredWeekdayStatus[entry.key] = Map<String, bool>.from(entry.value as Map);
        }
      }
      
      final restoredWeekdayDoseStatus = <String, Map<String, Map<int, bool>>>{};
      if (backupData['weekdayMedicationDoseStatus'] != null) {
        final doseStatusMap = backupData['weekdayMedicationDoseStatus'] as Map<String, dynamic>;
        for (final dateEntry in doseStatusMap.entries) {
          final dateKey = dateEntry.key;
          final memoStatusMap = dateEntry.value as Map<String, dynamic>;
          final memoStatus = <String, Map<int, bool>>{};
          
          for (final memoEntry in memoStatusMap.entries) {
            final memoId = memoEntry.key;
            final doseStatusMap = memoEntry.value as Map<String, dynamic>;
            final doseStatus = <int, bool>{};
            
            for (final doseEntry in doseStatusMap.entries) {
              final doseIndex = int.parse(doseEntry.key);
              doseStatus[doseIndex] = doseEntry.value as bool;
            }
            
            memoStatus[memoId] = doseStatus;
          }
          
          restoredWeekdayDoseStatus[dateKey] = memoStatus;
        }
      }
      
      final restoredMemoStatus = backupData['medicationMemoStatus'] != null
          ? Map<String, bool>.from(backupData['medicationMemoStatus'] as Map)
          : <String, bool>{};
      
      // 6. カレンダー色の復元（int → Color）
      final restoredDayColors = <String, Color>{};
      if (backupData['dayColors'] != null) {
        final colorsMap = backupData['dayColors'] as Map<String, dynamic>;
        for (final entry in colorsMap.entries) {
          restoredDayColors[entry.key] = Color(entry.value as int);
        }
      }
      
      // 7. アラームの復元
      final restoredAlarmList = (backupData['alarmList'] as List? ?? [])
          .map((alarm) => Map<String, dynamic>.from(alarm as Map))
          .toList();
      
      final restoredAlarmSettings = backupData['alarmSettings'] != null
          ? Map<String, dynamic>.from(backupData['alarmSettings'] as Map)
          : <String, dynamic>{};
      
      // 8. 統計データの復元
      final restoredAdherenceRates = backupData['adherenceRates'] != null
          ? Map<String, double>.from(backupData['adherenceRates'] as Map)
          : <String, double>{};
      
      // 9. アラームをSharedPreferencesに保存
      final prefs = await SharedPreferences.getInstance();
      await prefs.setInt('alarm_count', restoredAlarmList.length);
      
      for (int i = 0; i < restoredAlarmList.length; i++) {
        final alarm = restoredAlarmList[i];
        await prefs.setString('alarm_${i}_name', alarm['name']?.toString() ?? 'アラーム');
        await prefs.setString('alarm_${i}_time', alarm['time']?.toString() ?? '00:00');
        await prefs.setString('alarm_${i}_repeat', alarm['repeat']?.toString() ?? '一度だけ');
        await prefs.setString('alarm_${i}_alarmType', alarm['alarmType']?.toString() ?? 'sound');
        await prefs.setBool('alarm_${i}_enabled', alarm['enabled'] as bool? ?? true);
        await prefs.setBool('alarm_${i}_isRepeatEnabled', alarm['isRepeatEnabled'] as bool? ?? false);
        await prefs.setInt('alarm_${i}_volume', alarm['volume'] as int? ?? 80);
        
        // 曜日データ（型安全に復元）
        final dynamic selectedDaysRaw = alarm['selectedDays'];
        final List<bool> selectedDays = selectedDaysRaw is List
            ? List<bool>.from(selectedDaysRaw.map((e) => e == true))
            : <bool>[false, false, false, false, false, false, false];
        for (int j = 0; j < 7; j++) {
          await prefs.setBool('alarm_${i}_day_$j', j < selectedDays.length ? selectedDays[j] : false);
        }
      }
      
      // 10. 一括setState（1回のみ）
      if (!mounted) return;
      
      setState(() {
        _medicationMemos = restoredMemos;
        _addedMedications = restoredAddedMedications;
        _medicines = restoredMedicines;
        _medicationData = restoredMedicationData;
        _weekdayMedicationStatus = restoredWeekdayStatus;
        _weekdayMedicationDoseStatus = restoredWeekdayDoseStatus;
        _medicationMemoStatus = restoredMemoStatus;
        _dayColors = restoredDayColors;
        _alarmList = restoredAlarmList;
        _alarmSettings = restoredAlarmSettings;
        _adherenceRates = restoredAdherenceRates;
        
        // ✅ SimpleAlarmAppを完全に再構築
        _alarmTabKey = UniqueKey();  // 新しいキーで強制再構築
      });
      
      // 11. データ保存（復元後）
      await _saveAllData();
      
      debugPrint('アラーム復元完了（強制再構築）: ${restoredAlarmList.length}件');
      debugPrint('バックアップ復元完了: ${restoredMemos.length}件のメモ');
    } catch (e) {
      debugPrint('データ復元エラー: $e');
      rethrow;
    }
  }




  // ✅ バックアップ履歴の更新（5件制限）
  Future<void> _updateBackupHistory(String backupName, String backupKey, {String type = 'manual'}) async {
    final prefs = await SharedPreferences.getInstance();
    final historyJson = prefs.getString('backup_history') ?? '[]';
    final history = List<Map<String, dynamic>>.from(jsonDecode(historyJson) as List);
    
    history.add({
      'name': backupName,
      'key': backupKey,
      'createdAt': DateTime.now().toIso8601String(),
      'type': type,
    });
    
    // 古い順に自動削除（最大5件まで保持）
    if (history.length > 5) {
      // 古いバックアップデータを削除
      final oldBackup = history.removeAt(0);
      await prefs.remove(oldBackup['key'] as String);
    }
    
    await prefs.setString('backup_history', jsonEncode(history));
  }

  // ✅ バックアップ履歴表示機能（強化版）
  Future<void> _showBackupHistory() async {
    if (!mounted) return;
    
    final prefs = await SharedPreferences.getInstance();
    final historyJson = prefs.getString('backup_history') ?? '[]';
    final history = List<Map<String, dynamic>>.from(jsonDecode(historyJson) as List);
    
    // 自動バックアップも含めて全てのバックアップを取得
    final allBackups = <Map<String, dynamic>>[];
    
    // 手動バックアップ履歴を追加
    for (final backup in history) {
      allBackups.add({
        ...backup,
        'type': 'manual',
        'source': '履歴',
      });
    }
    
    // 自動バックアップを追加
    final autoBackupKey = prefs.getString('last_auto_backup_key');
    if (autoBackupKey != null) {
      allBackups.add({
        'name': '自動バックアップ（最新）',
        'key': autoBackupKey,
        'createdAt': DateTime.now().toIso8601String(),
        'type': 'auto',
        'source': '自動',
      });
    }
    
    if (allBackups.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('バックアップがありません'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.history, color: Colors.blue),
            SizedBox(width: 8),
            Text('バックアップ一覧'),
          ],
        ),
        content: SizedBox(
          width: double.maxFinite,
          height: 500,
          child: ListView.builder(
            itemCount: allBackups.length,
            itemBuilder: (context, index) {
              final backup = allBackups[allBackups.length - 1 - index]; // 新しい順に表示
              final createdAt = DateTime.parse(backup['createdAt'] as String);
              final isAuto = backup['type'] == 'auto';
              
              return Card(
                margin: const EdgeInsets.symmetric(vertical: 4),
                child: ListTile(
                  leading: Icon(
                    isAuto ? Icons.schedule : Icons.backup,
                    color: isAuto ? Colors.green : Colors.orange,
                  ),
                  title: Text(backup['name'] as String),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(DateFormat('yyyy-MM-dd HH:mm').format(createdAt)),
                      Text(
                        '${backup['source']}バックアップ',
                        style: TextStyle(
                          fontSize: 12,
                          color: isAuto ? Colors.green : Colors.blue,
                        ),
                      ),
                    ],
                  ),
                  trailing: PopupMenuButton<String>(
                    onSelected: (value) async {
                      switch (value) {
                        case 'restore':
                          await _restoreBackup(backup['key'] as String);
                          break;
                        case 'delete':
                          if (!isAuto) {
                            await _deleteBackup(backup['key'] as String, index);
                          }
                          break;
                        case 'preview':
                          await _previewBackup(backup['key'] as String);
                          break;
                      }
                    },
                    itemBuilder: (context) => [
                      const PopupMenuItem(
                        value: 'restore',
                        child: Row(
                          children: [
                            Icon(Icons.restore, color: Colors.blue),
                            SizedBox(width: 8),
                            Text('復元'),
                          ],
                        ),
                      ),
                      const PopupMenuItem(
                        value: 'preview',
                        child: Row(
                          children: [
                            Icon(Icons.visibility, color: Colors.green),
                            SizedBox(width: 8),
                            Text('プレビュー'),
                          ],
                        ),
                      ),
                      if (!isAuto) const PopupMenuItem(
                        value: 'delete',
                        child: Row(
                          children: [
                            Icon(Icons.delete, color: Colors.red),
                            SizedBox(width: 8),
                            Text('削除'),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('閉じる'),
          ),
        ],
      ),
    );
  }

  // ✅ バックアッププレビュー機能
  Future<void> _previewBackup(String backupKey) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final encryptedData = prefs.getString(backupKey);
      
      if (encryptedData == null) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('バックアップデータが見つかりません'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }
      
      final decryptedData = await _decryptDataAsync(encryptedData);
      final backupData = jsonDecode(decryptedData);
      
      if (mounted) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('バックアッププレビュー'),
            content: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('名前: ${backupData['name'] as String}'),
                  Text('作成日時: ${DateFormat('yyyy-MM-dd HH:mm').format(DateTime.parse(backupData['createdAt']))}'),
                  const SizedBox(height: 8),
                  const Text('📊 バックアップ内容:', style: TextStyle(fontWeight: FontWeight.bold)),
                  Text('・服用メモ数: ${(backupData['medicationMemos'] as List).length}件'),
                  Text('・追加薬品数: ${(backupData['addedMedications'] as List).length}件'),
                  Text('・薬品データ数: ${(backupData['medicines'] as List).length}件'),
                  Text('・アラーム数: ${(backupData['alarmList'] as List).length}件'),
                  Text('・カレンダー色設定: ${(backupData['dayColors'] as Map).length}日分'),
                  Text('・チェック状態: ${(backupData['weekdayMedicationStatus'] as Map).length}日分'),
                  Text('・服用率データ: ${(backupData['adherenceRates'] as Map).length}件'),
                  const SizedBox(height: 16),
                  const Text('このバックアップを復元しますか？'),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('キャンセル'),
              ),
              ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop();
                  _restoreBackup(backupKey);
                },
                child: const Text('復元する'),
              ),
            ],
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('プレビューの表示に失敗しました: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  // ✅ バックアップ復元機能（最適化版）
  Future<void> _restoreBackup(String backupKey) async {
    // ローディング表示
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
              SizedBox(width: 8),
              Text('バックアップを復元中...'),
            ],
          ),
          duration: Duration(seconds: 2),
        ),
      );
    }
    
    try {
      // 非同期でバックアップデータを読み込み
      final backupData = await _loadBackupDataAsync(backupKey);
      
      if (backupData == null) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('バックアップデータが見つかりません'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }
      
      // ✅ 新しい最適化された復元処理を使用
      await _restoreDataAsync(backupData);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('バックアップを復元しました'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('バックアップの復元に失敗しました: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  // ✅ 非同期でバックアップデータを読み込み
  Future<Map<String, dynamic>?> _loadBackupDataAsync(String backupKey) async {
    final prefs = await SharedPreferences.getInstance();
    final encryptedData = prefs.getString(backupKey);
    
    if (encryptedData == null) return null;
    
    // 非同期で復号化
    final decryptedData = await _decryptDataAsync(encryptedData);
    return jsonDecode(decryptedData);
  }



  // ✅ バックアップ削除機能
  Future<void> _deleteBackup(String backupKey, int index) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // バックアップデータを削除
      await prefs.remove(backupKey);
      
      // 履歴から削除
      final historyJson = prefs.getString('backup_history') ?? '[]';
      final history = List<Map<String, dynamic>>.from(jsonDecode(historyJson) as List);
      history.removeAt(history.length - 1 - index);
      await prefs.setString('backup_history', jsonEncode(history));
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('バックアップを削除しました'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('バックアップの削除に失敗しました: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }





  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 4,
      child: Scaffold(
        resizeToAvoidBottomInset: false, // キーボード表示時のオーバーフローを防止
        appBar: AppBar(
          title: const Text(
            'サプリ＆おくすりスケジュール管理帳',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 2,
            textAlign: TextAlign.center,
          ),
          centerTitle: true,
          titleSpacing: 0,
          actions: [
            // 購入状態設定メニュー
              PopupMenuButton<String>(
              icon: const Icon(Icons.more_vert),
                onSelected: (value) {
                  switch (value) {
                  case 'purchase_status':
                    _showTrialStatus();
                      break;
                  case 'set_purchase_link':
                    _showPurchaseLinkDialog();
                      break;
                  case 'backup':
                    _showBackupDialog();
                      break;
                  // 開発用: 手動で購入状態/トライアル状態を切り替えるメニュー（本番では無効）
                  // case 'set_purchased':
                  //   _setPurchasedStatus();
                  //     break;
                  // case 'set_trial':
                  //   _setTrialStatus();
                  //     break;
                  }
                },
                itemBuilder: (context) => [
                  PopupMenuItem(
                  value: 'purchase_status',
                    child: Row(
                      children: [
                      const Icon(Icons.info, color: Colors.blue),
                        const SizedBox(width: 8),
                      const Text('購入状態'),
                      ],
                    ),
                  ),
                  PopupMenuItem(
                  value: 'set_purchase_link',
                    child: Row(
                      children: [
                      const Icon(Icons.payment, color: Colors.green),
                        const SizedBox(width: 8),
                      const Text('課金情報'),
                      ],
                    ),
                  ),
                  // ✅ 修正：バックアップ機能を追加
                  PopupMenuItem(
                    value: 'backup',
                    child: Row(
                      children: [
                        const Icon(Icons.backup, color: Colors.orange),
                        const SizedBox(width: 8),
                        const Text('バックアップ'),
                      ],
                    ),
                  ),
                  // 開発用: 手動切替メニュー（本番ではコメントアウト）
                  // PopupMenuItem(
                  // value: 'set_purchased',
                  //   child: Row(
                  //     children: [
                  //     const Icon(Icons.check_circle, color: Colors.green),
                  //       const SizedBox(width: 8),
                  //     const Text('購入状態にする（開発用）'),
                  //     ],
                  //   ),
                  // ),
                  // PopupMenuItem(
                  // value: 'set_trial',
                  //   child: Row(
                  //     children: [
                  //     const Icon(Icons.timer, color: Colors.blue),
                  //       const SizedBox(width: 8),
                  //     const Text('トライアル状態にする（開発用）'),
                  //     ],
                  //   ),
                  // ),
              ],
            ),
          ],
          bottom: TabBar(
            controller: _tabController,
            isScrollable: true,
            tabAlignment: TabAlignment.start,
            tabs: const [
              Tab(icon: Icon(Icons.calendar_month), text: 'カレンダー'),
              Tab(icon: Icon(Icons.medication), text: '服用メモ'),
              Tab(icon: Icon(Icons.alarm), text: 'アラーム'),
              Tab(icon: Icon(Icons.analytics), text: '統計'),
            ],
          ),
        ),
        body: _isInitialized
          ? Card(
              margin: EdgeInsets.symmetric(
                horizontal: MediaQuery.of(context).size.width * 0.02, // 画面幅の2%
                vertical: 8,
              ),
              elevation: 4,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(16),
                child: TabBarView(
                  controller: _tabController,
                  children: [
                    // カレンダータブ
                    _buildCalendarTab(),
                    // 薬品タブ
                    _buildMedicineTab(),
                    // 服用アラームタブ
                    _buildAlarmTab(),
                    // 統計タブ
                    _buildStatsTab(),
                  ],
                ),
              ),
            )
          : const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text(
                    'アプリを初期化中...',
                    style: TextStyle(fontSize: 16),
                  ),
                ],
              ),
        ),
        // 服用メモタブでのみFloatingActionButtonを表示
        floatingActionButton: _tabController.index == 1 
          ? FloatingActionButton(
              onPressed: _addMemo,
              backgroundColor: Colors.blue,
              child: const Icon(Icons.add, color: Colors.white),
            )
          : null,
      ),
    );
  }

  // スクロール上端に到達した時の処理（画面遷移なし）
  void _onScrollToTop() {
    debugPrint('服用記録リスト上端に到達');
    // 画面遷移を削除 - ユーザーが手動でスクロールできるようにする
  }

  // スクロール下端に到達した時の処理（画面遷移なし）
  void _onScrollToBottom() {
    debugPrint('服用記録リスト下端に到達');
    // 画面遷移を削除 - ユーザーが手動で上にスクロールできるようにする
  }





  // 上端でのナビゲーションヒント表示
  void _showTopNavigationHint() {
    // 軽いハプティックフィードバックで上端到達を通知
